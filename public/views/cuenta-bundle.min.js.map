{"version":3,"sources":["cuenta-bundle.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","35","eval","4","54","55","7","79","83"],"mappings":";CAAS,SAAUA,GAKT,QAASC,GAAoBC,GAG5B,GAAGC,EAAiBD,GACnB,MAAOC,GAAiBD,GAAUE,OAGnC,IAAIC,GAASF,EAAiBD,IAC7BI,EAAGJ,EACHK,GAAG,EACHH,WAUD,OANAJ,GAAQE,GAAUM,KAAKH,EAAOD,QAASC,EAAQA,EAAOD,QAASH,GAG/DI,EAAOE,GAAI,EAGJF,EAAOD,QAvBf,GAAID,KA4BJF,GAAoBQ,EAAIT,EAGxBC,EAAoBS,EAAIP,EAGxBF,EAAoBK,EAAI,SAASK,GAAS,MAAOA,IAGjDV,EAAoBW,EAAI,SAASR,EAASS,EAAMC,GAC3Cb,EAAoBc,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,GAC9BK,cAAc,EACdC,YAAY,EACZC,IAAKN,KAMRb,EAAoBoB,EAAI,SAAShB,GAChC,GAAIS,GAAST,GAAUA,EAAOiB,WAC7B,WAAwB,MAAOjB,GAAgB,SAC/C,WAA8B,MAAOA,GAEtC,OADAJ,GAAoBW,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRb,EAAoBc,EAAI,SAASQ,EAAQC,GAAY,MAAOR,QAAOS,UAAUC,eAAelB,KAAKe,EAAQC,IAGzGvB,EAAoB0B,EAAI,GAGjB1B,EAAoBA,EAAoB2B,EAAI,MAKvDC,GACA,SAAUxB,OAAQD,QAASH,qBAEjC6B,KAAK;;EAICC,EACA,SAAU1B,OAAQD,SAExB0B,KAAK;;EAICE,GACA,SAAU3B,OAAQD,QAASH,qBAEjC6B,KAAK,40GAICG,GACA,SAAU5B,OAAQD,SAExB0B,KAAK,mpiBAICI,EACA,SAAU7B,OAAQD,QAASH,qBAEjC6B,KAAK;;EAICK,GACA,SAAU9B,OAAQD,QAASH,qBAEjC6B,KAAK,kjCAICM,GACA,SAAU/B,OAAQD,SAExB0B,KAAK","file":"cuenta-bundle.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 79);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 35:\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"var require;var require;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n\\n},{}],2:[function(require,module,exports){\\n/* MIT license */\\n\\nmodule.exports = {\\n  rgb2hsl: rgb2hsl,\\n  rgb2hsv: rgb2hsv,\\n  rgb2hwb: rgb2hwb,\\n  rgb2cmyk: rgb2cmyk,\\n  rgb2keyword: rgb2keyword,\\n  rgb2xyz: rgb2xyz,\\n  rgb2lab: rgb2lab,\\n  rgb2lch: rgb2lch,\\n\\n  hsl2rgb: hsl2rgb,\\n  hsl2hsv: hsl2hsv,\\n  hsl2hwb: hsl2hwb,\\n  hsl2cmyk: hsl2cmyk,\\n  hsl2keyword: hsl2keyword,\\n\\n  hsv2rgb: hsv2rgb,\\n  hsv2hsl: hsv2hsl,\\n  hsv2hwb: hsv2hwb,\\n  hsv2cmyk: hsv2cmyk,\\n  hsv2keyword: hsv2keyword,\\n\\n  hwb2rgb: hwb2rgb,\\n  hwb2hsl: hwb2hsl,\\n  hwb2hsv: hwb2hsv,\\n  hwb2cmyk: hwb2cmyk,\\n  hwb2keyword: hwb2keyword,\\n\\n  cmyk2rgb: cmyk2rgb,\\n  cmyk2hsl: cmyk2hsl,\\n  cmyk2hsv: cmyk2hsv,\\n  cmyk2hwb: cmyk2hwb,\\n  cmyk2keyword: cmyk2keyword,\\n\\n  keyword2rgb: keyword2rgb,\\n  keyword2hsl: keyword2hsl,\\n  keyword2hsv: keyword2hsv,\\n  keyword2hwb: keyword2hwb,\\n  keyword2cmyk: keyword2cmyk,\\n  keyword2lab: keyword2lab,\\n  keyword2xyz: keyword2xyz,\\n\\n  xyz2rgb: xyz2rgb,\\n  xyz2lab: xyz2lab,\\n  xyz2lch: xyz2lch,\\n\\n  lab2xyz: lab2xyz,\\n  lab2rgb: lab2rgb,\\n  lab2lch: lab2lch,\\n\\n  lch2lab: lch2lab,\\n  lch2xyz: lch2xyz,\\n  lch2rgb: lch2rgb\\n}\\n\\n\\nfunction rgb2hsl(rgb) {\\n  var r = rgb[0]/255,\\n      g = rgb[1]/255,\\n      b = rgb[2]/255,\\n      min = Math.min(r, g, b),\\n      max = Math.max(r, g, b),\\n      delta = max - min,\\n      h, s, l;\\n\\n  if (max == min)\\n    h = 0;\\n  else if (r == max)\\n    h = (g - b) / delta;\\n  else if (g == max)\\n    h = 2 + (b - r) / delta;\\n  else if (b == max)\\n    h = 4 + (r - g)/ delta;\\n\\n  h = Math.min(h * 60, 360);\\n\\n  if (h < 0)\\n    h += 360;\\n\\n  l = (min + max) / 2;\\n\\n  if (max == min)\\n    s = 0;\\n  else if (l <= 0.5)\\n    s = delta / (max + min);\\n  else\\n    s = delta / (2 - max - min);\\n\\n  return [h, s * 100, l * 100];\\n}\\n\\nfunction rgb2hsv(rgb) {\\n  var r = rgb[0],\\n      g = rgb[1],\\n      b = rgb[2],\\n      min = Math.min(r, g, b),\\n      max = Math.max(r, g, b),\\n      delta = max - min,\\n      h, s, v;\\n\\n  if (max == 0)\\n    s = 0;\\n  else\\n    s = (delta/max * 1000)/10;\\n\\n  if (max == min)\\n    h = 0;\\n  else if (r == max)\\n    h = (g - b) / delta;\\n  else if (g == max)\\n    h = 2 + (b - r) / delta;\\n  else if (b == max)\\n    h = 4 + (r - g) / delta;\\n\\n  h = Math.min(h * 60, 360);\\n\\n  if (h < 0)\\n    h += 360;\\n\\n  v = ((max / 255) * 1000) / 10;\\n\\n  return [h, s, v];\\n}\\n\\nfunction rgb2hwb(rgb) {\\n  var r = rgb[0],\\n      g = rgb[1],\\n      b = rgb[2],\\n      h = rgb2hsl(rgb)[0],\\n      w = 1/255 * Math.min(r, Math.min(g, b)),\\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\\n\\n  return [h, w * 100, b * 100];\\n}\\n\\nfunction rgb2cmyk(rgb) {\\n  var r = rgb[0] / 255,\\n      g = rgb[1] / 255,\\n      b = rgb[2] / 255,\\n      c, m, y, k;\\n\\n  k = Math.min(1 - r, 1 - g, 1 - b);\\n  c = (1 - r - k) / (1 - k) || 0;\\n  m = (1 - g - k) / (1 - k) || 0;\\n  y = (1 - b - k) / (1 - k) || 0;\\n  return [c * 100, m * 100, y * 100, k * 100];\\n}\\n\\nfunction rgb2keyword(rgb) {\\n  return reverseKeywords[JSON.stringify(rgb)];\\n}\\n\\nfunction rgb2xyz(rgb) {\\n  var r = rgb[0] / 255,\\n      g = rgb[1] / 255,\\n      b = rgb[2] / 255;\\n\\n  // assume sRGB\\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\\n\\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\\n\\n  return [x * 100, y *100, z * 100];\\n}\\n\\nfunction rgb2lab(rgb) {\\n  var xyz = rgb2xyz(rgb),\\n        x = xyz[0],\\n        y = xyz[1],\\n        z = xyz[2],\\n        l, a, b;\\n\\n  x /= 95.047;\\n  y /= 100;\\n  z /= 108.883;\\n\\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\\n\\n  l = (116 * y) - 16;\\n  a = 500 * (x - y);\\n  b = 200 * (y - z);\\n\\n  return [l, a, b];\\n}\\n\\nfunction rgb2lch(args) {\\n  return lab2lch(rgb2lab(args));\\n}\\n\\nfunction hsl2rgb(hsl) {\\n  var h = hsl[0] / 360,\\n      s = hsl[1] / 100,\\n      l = hsl[2] / 100,\\n      t1, t2, t3, rgb, val;\\n\\n  if (s == 0) {\\n    val = l * 255;\\n    return [val, val, val];\\n  }\\n\\n  if (l < 0.5)\\n    t2 = l * (1 + s);\\n  else\\n    t2 = l + s - l * s;\\n  t1 = 2 * l - t2;\\n\\n  rgb = [0, 0, 0];\\n  for (var i = 0; i < 3; i++) {\\n    t3 = h + 1 / 3 * - (i - 1);\\n    t3 < 0 && t3++;\\n    t3 > 1 && t3--;\\n\\n    if (6 * t3 < 1)\\n      val = t1 + (t2 - t1) * 6 * t3;\\n    else if (2 * t3 < 1)\\n      val = t2;\\n    else if (3 * t3 < 2)\\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\\n    else\\n      val = t1;\\n\\n    rgb[i] = val * 255;\\n  }\\n\\n  return rgb;\\n}\\n\\nfunction hsl2hsv(hsl) {\\n  var h = hsl[0],\\n      s = hsl[1] / 100,\\n      l = hsl[2] / 100,\\n      sv, v;\\n\\n  if(l === 0) {\\n      // no need to do calc on black\\n      // also avoids divide by 0 error\\n      return [0, 0, 0];\\n  }\\n\\n  l *= 2;\\n  s *= (l <= 1) ? l : 2 - l;\\n  v = (l + s) / 2;\\n  sv = (2 * s) / (l + s);\\n  return [h, sv * 100, v * 100];\\n}\\n\\nfunction hsl2hwb(args) {\\n  return rgb2hwb(hsl2rgb(args));\\n}\\n\\nfunction hsl2cmyk(args) {\\n  return rgb2cmyk(hsl2rgb(args));\\n}\\n\\nfunction hsl2keyword(args) {\\n  return rgb2keyword(hsl2rgb(args));\\n}\\n\\n\\nfunction hsv2rgb(hsv) {\\n  var h = hsv[0] / 60,\\n      s = hsv[1] / 100,\\n      v = hsv[2] / 100,\\n      hi = Math.floor(h) % 6;\\n\\n  var f = h - Math.floor(h),\\n      p = 255 * v * (1 - s),\\n      q = 255 * v * (1 - (s * f)),\\n      t = 255 * v * (1 - (s * (1 - f))),\\n      v = 255 * v;\\n\\n  switch(hi) {\\n    case 0:\\n      return [v, t, p];\\n    case 1:\\n      return [q, v, p];\\n    case 2:\\n      return [p, v, t];\\n    case 3:\\n      return [p, q, v];\\n    case 4:\\n      return [t, p, v];\\n    case 5:\\n      return [v, p, q];\\n  }\\n}\\n\\nfunction hsv2hsl(hsv) {\\n  var h = hsv[0],\\n      s = hsv[1] / 100,\\n      v = hsv[2] / 100,\\n      sl, l;\\n\\n  l = (2 - s) * v;\\n  sl = s * v;\\n  sl /= (l <= 1) ? l : 2 - l;\\n  sl = sl || 0;\\n  l /= 2;\\n  return [h, sl * 100, l * 100];\\n}\\n\\nfunction hsv2hwb(args) {\\n  return rgb2hwb(hsv2rgb(args))\\n}\\n\\nfunction hsv2cmyk(args) {\\n  return rgb2cmyk(hsv2rgb(args));\\n}\\n\\nfunction hsv2keyword(args) {\\n  return rgb2keyword(hsv2rgb(args));\\n}\\n\\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\\nfunction hwb2rgb(hwb) {\\n  var h = hwb[0] / 360,\\n      wh = hwb[1] / 100,\\n      bl = hwb[2] / 100,\\n      ratio = wh + bl,\\n      i, v, f, n;\\n\\n  // wh + bl cant be > 1\\n  if (ratio > 1) {\\n    wh /= ratio;\\n    bl /= ratio;\\n  }\\n\\n  i = Math.floor(6 * h);\\n  v = 1 - bl;\\n  f = 6 * h - i;\\n  if ((i & 0x01) != 0) {\\n    f = 1 - f;\\n  }\\n  n = wh + f * (v - wh);  // linear interpolation\\n\\n  switch (i) {\\n    default:\\n    case 6:\\n    case 0: r = v; g = n; b = wh; break;\\n    case 1: r = n; g = v; b = wh; break;\\n    case 2: r = wh; g = v; b = n; break;\\n    case 3: r = wh; g = n; b = v; break;\\n    case 4: r = n; g = wh; b = v; break;\\n    case 5: r = v; g = wh; b = n; break;\\n  }\\n\\n  return [r * 255, g * 255, b * 255];\\n}\\n\\nfunction hwb2hsl(args) {\\n  return rgb2hsl(hwb2rgb(args));\\n}\\n\\nfunction hwb2hsv(args) {\\n  return rgb2hsv(hwb2rgb(args));\\n}\\n\\nfunction hwb2cmyk(args) {\\n  return rgb2cmyk(hwb2rgb(args));\\n}\\n\\nfunction hwb2keyword(args) {\\n  return rgb2keyword(hwb2rgb(args));\\n}\\n\\nfunction cmyk2rgb(cmyk) {\\n  var c = cmyk[0] / 100,\\n      m = cmyk[1] / 100,\\n      y = cmyk[2] / 100,\\n      k = cmyk[3] / 100,\\n      r, g, b;\\n\\n  r = 1 - Math.min(1, c * (1 - k) + k);\\n  g = 1 - Math.min(1, m * (1 - k) + k);\\n  b = 1 - Math.min(1, y * (1 - k) + k);\\n  return [r * 255, g * 255, b * 255];\\n}\\n\\nfunction cmyk2hsl(args) {\\n  return rgb2hsl(cmyk2rgb(args));\\n}\\n\\nfunction cmyk2hsv(args) {\\n  return rgb2hsv(cmyk2rgb(args));\\n}\\n\\nfunction cmyk2hwb(args) {\\n  return rgb2hwb(cmyk2rgb(args));\\n}\\n\\nfunction cmyk2keyword(args) {\\n  return rgb2keyword(cmyk2rgb(args));\\n}\\n\\n\\nfunction xyz2rgb(xyz) {\\n  var x = xyz[0] / 100,\\n      y = xyz[1] / 100,\\n      z = xyz[2] / 100,\\n      r, g, b;\\n\\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\\n\\n  // assume sRGB\\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\\n    : r = (r * 12.92);\\n\\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\\n    : g = (g * 12.92);\\n\\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\\n    : b = (b * 12.92);\\n\\n  r = Math.min(Math.max(0, r), 1);\\n  g = Math.min(Math.max(0, g), 1);\\n  b = Math.min(Math.max(0, b), 1);\\n\\n  return [r * 255, g * 255, b * 255];\\n}\\n\\nfunction xyz2lab(xyz) {\\n  var x = xyz[0],\\n      y = xyz[1],\\n      z = xyz[2],\\n      l, a, b;\\n\\n  x /= 95.047;\\n  y /= 100;\\n  z /= 108.883;\\n\\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\\n\\n  l = (116 * y) - 16;\\n  a = 500 * (x - y);\\n  b = 200 * (y - z);\\n\\n  return [l, a, b];\\n}\\n\\nfunction xyz2lch(args) {\\n  return lab2lch(xyz2lab(args));\\n}\\n\\nfunction lab2xyz(lab) {\\n  var l = lab[0],\\n      a = lab[1],\\n      b = lab[2],\\n      x, y, z, y2;\\n\\n  if (l <= 8) {\\n    y = (l * 100) / 903.3;\\n    y2 = (7.787 * (y / 100)) + (16 / 116);\\n  } else {\\n    y = 100 * Math.pow((l + 16) / 116, 3);\\n    y2 = Math.pow(y / 100, 1/3);\\n  }\\n\\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\\n\\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\\n\\n  return [x, y, z];\\n}\\n\\nfunction lab2lch(lab) {\\n  var l = lab[0],\\n      a = lab[1],\\n      b = lab[2],\\n      hr, h, c;\\n\\n  hr = Math.atan2(b, a);\\n  h = hr * 360 / 2 / Math.PI;\\n  if (h < 0) {\\n    h += 360;\\n  }\\n  c = Math.sqrt(a * a + b * b);\\n  return [l, c, h];\\n}\\n\\nfunction lab2rgb(args) {\\n  return xyz2rgb(lab2xyz(args));\\n}\\n\\nfunction lch2lab(lch) {\\n  var l = lch[0],\\n      c = lch[1],\\n      h = lch[2],\\n      a, b, hr;\\n\\n  hr = h / 360 * 2 * Math.PI;\\n  a = c * Math.cos(hr);\\n  b = c * Math.sin(hr);\\n  return [l, a, b];\\n}\\n\\nfunction lch2xyz(args) {\\n  return lab2xyz(lch2lab(args));\\n}\\n\\nfunction lch2rgb(args) {\\n  return lab2rgb(lch2lab(args));\\n}\\n\\nfunction keyword2rgb(keyword) {\\n  return cssKeywords[keyword];\\n}\\n\\nfunction keyword2hsl(args) {\\n  return rgb2hsl(keyword2rgb(args));\\n}\\n\\nfunction keyword2hsv(args) {\\n  return rgb2hsv(keyword2rgb(args));\\n}\\n\\nfunction keyword2hwb(args) {\\n  return rgb2hwb(keyword2rgb(args));\\n}\\n\\nfunction keyword2cmyk(args) {\\n  return rgb2cmyk(keyword2rgb(args));\\n}\\n\\nfunction keyword2lab(args) {\\n  return rgb2lab(keyword2rgb(args));\\n}\\n\\nfunction keyword2xyz(args) {\\n  return rgb2xyz(keyword2rgb(args));\\n}\\n\\nvar cssKeywords = {\\n  aliceblue:  [240,248,255],\\n  antiquewhite: [250,235,215],\\n  aqua: [0,255,255],\\n  aquamarine: [127,255,212],\\n  azure:  [240,255,255],\\n  beige:  [245,245,220],\\n  bisque: [255,228,196],\\n  black:  [0,0,0],\\n  blanchedalmond: [255,235,205],\\n  blue: [0,0,255],\\n  blueviolet: [138,43,226],\\n  brown:  [165,42,42],\\n  burlywood:  [222,184,135],\\n  cadetblue:  [95,158,160],\\n  chartreuse: [127,255,0],\\n  chocolate:  [210,105,30],\\n  coral:  [255,127,80],\\n  cornflowerblue: [100,149,237],\\n  cornsilk: [255,248,220],\\n  crimson:  [220,20,60],\\n  cyan: [0,255,255],\\n  darkblue: [0,0,139],\\n  darkcyan: [0,139,139],\\n  darkgoldenrod:  [184,134,11],\\n  darkgray: [169,169,169],\\n  darkgreen:  [0,100,0],\\n  darkgrey: [169,169,169],\\n  darkkhaki:  [189,183,107],\\n  darkmagenta:  [139,0,139],\\n  darkolivegreen: [85,107,47],\\n  darkorange: [255,140,0],\\n  darkorchid: [153,50,204],\\n  darkred:  [139,0,0],\\n  darksalmon: [233,150,122],\\n  darkseagreen: [143,188,143],\\n  darkslateblue:  [72,61,139],\\n  darkslategray:  [47,79,79],\\n  darkslategrey:  [47,79,79],\\n  darkturquoise:  [0,206,209],\\n  darkviolet: [148,0,211],\\n  deeppink: [255,20,147],\\n  deepskyblue:  [0,191,255],\\n  dimgray:  [105,105,105],\\n  dimgrey:  [105,105,105],\\n  dodgerblue: [30,144,255],\\n  firebrick:  [178,34,34],\\n  floralwhite:  [255,250,240],\\n  forestgreen:  [34,139,34],\\n  fuchsia:  [255,0,255],\\n  gainsboro:  [220,220,220],\\n  ghostwhite: [248,248,255],\\n  gold: [255,215,0],\\n  goldenrod:  [218,165,32],\\n  gray: [128,128,128],\\n  green:  [0,128,0],\\n  greenyellow:  [173,255,47],\\n  grey: [128,128,128],\\n  honeydew: [240,255,240],\\n  hotpink:  [255,105,180],\\n  indianred:  [205,92,92],\\n  indigo: [75,0,130],\\n  ivory:  [255,255,240],\\n  khaki:  [240,230,140],\\n  lavender: [230,230,250],\\n  lavenderblush:  [255,240,245],\\n  lawngreen:  [124,252,0],\\n  lemonchiffon: [255,250,205],\\n  lightblue:  [173,216,230],\\n  lightcoral: [240,128,128],\\n  lightcyan:  [224,255,255],\\n  lightgoldenrodyellow: [250,250,210],\\n  lightgray:  [211,211,211],\\n  lightgreen: [144,238,144],\\n  lightgrey:  [211,211,211],\\n  lightpink:  [255,182,193],\\n  lightsalmon:  [255,160,122],\\n  lightseagreen:  [32,178,170],\\n  lightskyblue: [135,206,250],\\n  lightslategray: [119,136,153],\\n  lightslategrey: [119,136,153],\\n  lightsteelblue: [176,196,222],\\n  lightyellow:  [255,255,224],\\n  lime: [0,255,0],\\n  limegreen:  [50,205,50],\\n  linen:  [250,240,230],\\n  magenta:  [255,0,255],\\n  maroon: [128,0,0],\\n  mediumaquamarine: [102,205,170],\\n  mediumblue: [0,0,205],\\n  mediumorchid: [186,85,211],\\n  mediumpurple: [147,112,219],\\n  mediumseagreen: [60,179,113],\\n  mediumslateblue:  [123,104,238],\\n  mediumspringgreen:  [0,250,154],\\n  mediumturquoise:  [72,209,204],\\n  mediumvioletred:  [199,21,133],\\n  midnightblue: [25,25,112],\\n  mintcream:  [245,255,250],\\n  mistyrose:  [255,228,225],\\n  moccasin: [255,228,181],\\n  navajowhite:  [255,222,173],\\n  navy: [0,0,128],\\n  oldlace:  [253,245,230],\\n  olive:  [128,128,0],\\n  olivedrab:  [107,142,35],\\n  orange: [255,165,0],\\n  orangered:  [255,69,0],\\n  orchid: [218,112,214],\\n  palegoldenrod:  [238,232,170],\\n  palegreen:  [152,251,152],\\n  paleturquoise:  [175,238,238],\\n  palevioletred:  [219,112,147],\\n  papayawhip: [255,239,213],\\n  peachpuff:  [255,218,185],\\n  peru: [205,133,63],\\n  pink: [255,192,203],\\n  plum: [221,160,221],\\n  powderblue: [176,224,230],\\n  purple: [128,0,128],\\n  rebeccapurple: [102, 51, 153],\\n  red:  [255,0,0],\\n  rosybrown:  [188,143,143],\\n  royalblue:  [65,105,225],\\n  saddlebrown:  [139,69,19],\\n  salmon: [250,128,114],\\n  sandybrown: [244,164,96],\\n  seagreen: [46,139,87],\\n  seashell: [255,245,238],\\n  sienna: [160,82,45],\\n  silver: [192,192,192],\\n  skyblue:  [135,206,235],\\n  slateblue:  [106,90,205],\\n  slategray:  [112,128,144],\\n  slategrey:  [112,128,144],\\n  snow: [255,250,250],\\n  springgreen:  [0,255,127],\\n  steelblue:  [70,130,180],\\n  tan:  [210,180,140],\\n  teal: [0,128,128],\\n  thistle:  [216,191,216],\\n  tomato: [255,99,71],\\n  turquoise:  [64,224,208],\\n  violet: [238,130,238],\\n  wheat:  [245,222,179],\\n  white:  [255,255,255],\\n  whitesmoke: [245,245,245],\\n  yellow: [255,255,0],\\n  yellowgreen:  [154,205,50]\\n};\\n\\nvar reverseKeywords = {};\\nfor (var key in cssKeywords) {\\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\\n}\\n\\n},{}],3:[function(require,module,exports){\\nvar conversions = require(\\\"./conversions\\\");\\n\\nvar convert = function() {\\n   return new Converter();\\n}\\n\\nfor (var func in conversions) {\\n  // export Raw versions\\n  convert[func + \\\"Raw\\\"] =  (function(func) {\\n    // accept array or plain args\\n    return function(arg) {\\n      if (typeof arg == \\\"number\\\")\\n        arg = Array.prototype.slice.call(arguments);\\n      return conversions[func](arg);\\n    }\\n  })(func);\\n\\n  var pair = /(\\\\w+)2(\\\\w+)/.exec(func),\\n      from = pair[1],\\n      to = pair[2];\\n\\n  // export rgb2hsl and [\\\"rgb\\\"][\\\"hsl\\\"]\\n  convert[from] = convert[from] || {};\\n\\n  convert[from][to] = convert[func] = (function(func) { \\n    return function(arg) {\\n      if (typeof arg == \\\"number\\\")\\n        arg = Array.prototype.slice.call(arguments);\\n      \\n      var val = conversions[func](arg);\\n      if (typeof val == \\\"string\\\" || val === undefined)\\n        return val; // keyword\\n\\n      for (var i = 0; i < val.length; i++)\\n        val[i] = Math.round(val[i]);\\n      return val;\\n    }\\n  })(func);\\n}\\n\\n\\n/* Converter does lazy conversion and caching */\\nvar Converter = function() {\\n   this.convs = {};\\n};\\n\\n/* Either get the values for a space or\\n  set the values for a space, depending on args */\\nConverter.prototype.routeSpace = function(space, args) {\\n   var values = args[0];\\n   if (values === undefined) {\\n      // color.rgb()\\n      return this.getValues(space);\\n   }\\n   // color.rgb(10, 10, 10)\\n   if (typeof values == \\\"number\\\") {\\n      values = Array.prototype.slice.call(args);        \\n   }\\n\\n   return this.setValues(space, values);\\n};\\n  \\n/* Set the values for a space, invalidating cache */\\nConverter.prototype.setValues = function(space, values) {\\n   this.space = space;\\n   this.convs = {};\\n   this.convs[space] = values;\\n   return this;\\n};\\n\\n/* Get the values for a space. If there's already\\n  a conversion for the space, fetch it, otherwise\\n  compute it */\\nConverter.prototype.getValues = function(space) {\\n   var vals = this.convs[space];\\n   if (!vals) {\\n      var fspace = this.space,\\n          from = this.convs[fspace];\\n      vals = convert[fspace][space](from);\\n\\n      this.convs[space] = vals;\\n   }\\n  return vals;\\n};\\n\\n[\\\"rgb\\\", \\\"hsl\\\", \\\"hsv\\\", \\\"cmyk\\\", \\\"keyword\\\"].forEach(function(space) {\\n   Converter.prototype[space] = function(vals) {\\n      return this.routeSpace(space, arguments);\\n   }\\n});\\n\\nmodule.exports = convert;\\n},{\\\"./conversions\\\":2}],4:[function(require,module,exports){\\n/* MIT license */\\nvar colorNames = require('color-name');\\n\\nmodule.exports = {\\n   getRgba: getRgba,\\n   getHsla: getHsla,\\n   getRgb: getRgb,\\n   getHsl: getHsl,\\n   getHwb: getHwb,\\n   getAlpha: getAlpha,\\n\\n   hexString: hexString,\\n   rgbString: rgbString,\\n   rgbaString: rgbaString,\\n   percentString: percentString,\\n   percentaString: percentaString,\\n   hslString: hslString,\\n   hslaString: hslaString,\\n   hwbString: hwbString,\\n   keyword: keyword\\n}\\n\\nfunction getRgba(string) {\\n   if (!string) {\\n      return;\\n   }\\n   var abbr =  /^#([a-fA-F0-9]{3})$/,\\n       hex =  /^#([a-fA-F0-9]{6})$/,\\n       rgba = /^rgba?\\\\(\\\\s*([+-]?\\\\d+)\\\\s*,\\\\s*([+-]?\\\\d+)\\\\s*,\\\\s*([+-]?\\\\d+)\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)$/,\\n       per = /^rgba?\\\\(\\\\s*([+-]?[\\\\d\\\\.]+)\\\\%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\%\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)$/,\\n       keyword = /(\\\\w+)/;\\n\\n   var rgb = [0, 0, 0],\\n       a = 1,\\n       match = string.match(abbr);\\n   if (match) {\\n      match = match[1];\\n      for (var i = 0; i < rgb.length; i++) {\\n         rgb[i] = parseInt(match[i] + match[i], 16);\\n      }\\n   }\\n   else if (match = string.match(hex)) {\\n      match = match[1];\\n      for (var i = 0; i < rgb.length; i++) {\\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\\n      }\\n   }\\n   else if (match = string.match(rgba)) {\\n      for (var i = 0; i < rgb.length; i++) {\\n         rgb[i] = parseInt(match[i + 1]);\\n      }\\n      a = parseFloat(match[4]);\\n   }\\n   else if (match = string.match(per)) {\\n      for (var i = 0; i < rgb.length; i++) {\\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\\n      }\\n      a = parseFloat(match[4]);\\n   }\\n   else if (match = string.match(keyword)) {\\n      if (match[1] == \\\"transparent\\\") {\\n         return [0, 0, 0, 0];\\n      }\\n      rgb = colorNames[match[1]];\\n      if (!rgb) {\\n         return;\\n      }\\n   }\\n\\n   for (var i = 0; i < rgb.length; i++) {\\n      rgb[i] = scale(rgb[i], 0, 255);\\n   }\\n   if (!a && a != 0) {\\n      a = 1;\\n   }\\n   else {\\n      a = scale(a, 0, 1);\\n   }\\n   rgb[3] = a;\\n   return rgb;\\n}\\n\\nfunction getHsla(string) {\\n   if (!string) {\\n      return;\\n   }\\n   var hsl = /^hsla?\\\\(\\\\s*([+-]?\\\\d+)(?:deg)?\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)/;\\n   var match = string.match(hsl);\\n   if (match) {\\n      var alpha = parseFloat(match[4]);\\n      var h = scale(parseInt(match[1]), 0, 360),\\n          s = scale(parseFloat(match[2]), 0, 100),\\n          l = scale(parseFloat(match[3]), 0, 100),\\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\\n      return [h, s, l, a];\\n   }\\n}\\n\\nfunction getHwb(string) {\\n   if (!string) {\\n      return;\\n   }\\n   var hwb = /^hwb\\\\(\\\\s*([+-]?\\\\d+)(?:deg)?\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)/;\\n   var match = string.match(hwb);\\n   if (match) {\\n    var alpha = parseFloat(match[4]);\\n      var h = scale(parseInt(match[1]), 0, 360),\\n          w = scale(parseFloat(match[2]), 0, 100),\\n          b = scale(parseFloat(match[3]), 0, 100),\\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\\n      return [h, w, b, a];\\n   }\\n}\\n\\nfunction getRgb(string) {\\n   var rgba = getRgba(string);\\n   return rgba && rgba.slice(0, 3);\\n}\\n\\nfunction getHsl(string) {\\n  var hsla = getHsla(string);\\n  return hsla && hsla.slice(0, 3);\\n}\\n\\nfunction getAlpha(string) {\\n   var vals = getRgba(string);\\n   if (vals) {\\n      return vals[3];\\n   }\\n   else if (vals = getHsla(string)) {\\n      return vals[3];\\n   }\\n   else if (vals = getHwb(string)) {\\n      return vals[3];\\n   }\\n}\\n\\n// generators\\nfunction hexString(rgb) {\\n   return \\\"#\\\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\\n              + hexDouble(rgb[2]);\\n}\\n\\nfunction rgbString(rgba, alpha) {\\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\\n      return rgbaString(rgba, alpha);\\n   }\\n   return \\\"rgb(\\\" + rgba[0] + \\\", \\\" + rgba[1] + \\\", \\\" + rgba[2] + \\\")\\\";\\n}\\n\\nfunction rgbaString(rgba, alpha) {\\n   if (alpha === undefined) {\\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\\n   }\\n   return \\\"rgba(\\\" + rgba[0] + \\\", \\\" + rgba[1] + \\\", \\\" + rgba[2]\\n           + \\\", \\\" + alpha + \\\")\\\";\\n}\\n\\nfunction percentString(rgba, alpha) {\\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\\n      return percentaString(rgba, alpha);\\n   }\\n   var r = Math.round(rgba[0]/255 * 100),\\n       g = Math.round(rgba[1]/255 * 100),\\n       b = Math.round(rgba[2]/255 * 100);\\n\\n   return \\\"rgb(\\\" + r + \\\"%, \\\" + g + \\\"%, \\\" + b + \\\"%)\\\";\\n}\\n\\nfunction percentaString(rgba, alpha) {\\n   var r = Math.round(rgba[0]/255 * 100),\\n       g = Math.round(rgba[1]/255 * 100),\\n       b = Math.round(rgba[2]/255 * 100);\\n   return \\\"rgba(\\\" + r + \\\"%, \\\" + g + \\\"%, \\\" + b + \\\"%, \\\" + (alpha || rgba[3] || 1) + \\\")\\\";\\n}\\n\\nfunction hslString(hsla, alpha) {\\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\\n      return hslaString(hsla, alpha);\\n   }\\n   return \\\"hsl(\\\" + hsla[0] + \\\", \\\" + hsla[1] + \\\"%, \\\" + hsla[2] + \\\"%)\\\";\\n}\\n\\nfunction hslaString(hsla, alpha) {\\n   if (alpha === undefined) {\\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\\n   }\\n   return \\\"hsla(\\\" + hsla[0] + \\\", \\\" + hsla[1] + \\\"%, \\\" + hsla[2] + \\\"%, \\\"\\n           + alpha + \\\")\\\";\\n}\\n\\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\\n// (hwb have alpha optional & 1 is default value)\\nfunction hwbString(hwb, alpha) {\\n   if (alpha === undefined) {\\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\\n   }\\n   return \\\"hwb(\\\" + hwb[0] + \\\", \\\" + hwb[1] + \\\"%, \\\" + hwb[2] + \\\"%\\\"\\n           + (alpha !== undefined && alpha !== 1 ? \\\", \\\" + alpha : \\\"\\\") + \\\")\\\";\\n}\\n\\nfunction keyword(rgb) {\\n  return reverseNames[rgb.slice(0, 3)];\\n}\\n\\n// helpers\\nfunction scale(num, min, max) {\\n   return Math.min(Math.max(min, num), max);\\n}\\n\\nfunction hexDouble(num) {\\n  var str = num.toString(16).toUpperCase();\\n  return (str.length < 2) ? \\\"0\\\" + str : str;\\n}\\n\\n\\n//create a list of reverse color names\\nvar reverseNames = {};\\nfor (var name in colorNames) {\\n   reverseNames[colorNames[name]] = name;\\n}\\n\\n},{\\\"color-name\\\":6}],5:[function(require,module,exports){\\n/* MIT license */\\n\\nvar convert = require(\\\"color-convert\\\"),\\n  string = require(\\\"color-string\\\");\\n\\nvar Color = function(obj) {\\n  if (obj instanceof Color) return obj;\\n  if (!(this instanceof Color)) return new Color(obj);\\n\\n  this.values = {\\n    rgb: [0, 0, 0],\\n    hsl: [0, 0, 0],\\n    hsv: [0, 0, 0],\\n    hwb: [0, 0, 0],\\n    cmyk: [0, 0, 0, 0],\\n    alpha: 1\\n  }\\n\\n  // parse Color() argument\\n  if (typeof obj == \\\"string\\\") {\\n    var vals = string.getRgba(obj);\\n    if (vals) {\\n      this.setValues(\\\"rgb\\\", vals);\\n    } else if (vals = string.getHsla(obj)) {\\n      this.setValues(\\\"hsl\\\", vals);\\n    } else if (vals = string.getHwb(obj)) {\\n      this.setValues(\\\"hwb\\\", vals);\\n    } else {\\n      throw new Error(\\\"Unable to parse color from string \\\\\\\"\\\" + obj + \\\"\\\\\\\"\\\");\\n    }\\n  } else if (typeof obj == \\\"object\\\") {\\n    var vals = obj;\\n    if (vals[\\\"r\\\"] !== undefined || vals[\\\"red\\\"] !== undefined) {\\n      this.setValues(\\\"rgb\\\", vals)\\n    } else if (vals[\\\"l\\\"] !== undefined || vals[\\\"lightness\\\"] !== undefined) {\\n      this.setValues(\\\"hsl\\\", vals)\\n    } else if (vals[\\\"v\\\"] !== undefined || vals[\\\"value\\\"] !== undefined) {\\n      this.setValues(\\\"hsv\\\", vals)\\n    } else if (vals[\\\"w\\\"] !== undefined || vals[\\\"whiteness\\\"] !== undefined) {\\n      this.setValues(\\\"hwb\\\", vals)\\n    } else if (vals[\\\"c\\\"] !== undefined || vals[\\\"cyan\\\"] !== undefined) {\\n      this.setValues(\\\"cmyk\\\", vals)\\n    } else {\\n      throw new Error(\\\"Unable to parse color from object \\\" + JSON.stringify(obj));\\n    }\\n  }\\n}\\n\\nColor.prototype = {\\n  rgb: function(vals) {\\n    return this.setSpace(\\\"rgb\\\", arguments);\\n  },\\n  hsl: function(vals) {\\n    return this.setSpace(\\\"hsl\\\", arguments);\\n  },\\n  hsv: function(vals) {\\n    return this.setSpace(\\\"hsv\\\", arguments);\\n  },\\n  hwb: function(vals) {\\n    return this.setSpace(\\\"hwb\\\", arguments);\\n  },\\n  cmyk: function(vals) {\\n    return this.setSpace(\\\"cmyk\\\", arguments);\\n  },\\n\\n  rgbArray: function() {\\n    return this.values.rgb;\\n  },\\n  hslArray: function() {\\n    return this.values.hsl;\\n  },\\n  hsvArray: function() {\\n    return this.values.hsv;\\n  },\\n  hwbArray: function() {\\n    if (this.values.alpha !== 1) {\\n      return this.values.hwb.concat([this.values.alpha])\\n    }\\n    return this.values.hwb;\\n  },\\n  cmykArray: function() {\\n    return this.values.cmyk;\\n  },\\n  rgbaArray: function() {\\n    var rgb = this.values.rgb;\\n    return rgb.concat([this.values.alpha]);\\n  },\\n  hslaArray: function() {\\n    var hsl = this.values.hsl;\\n    return hsl.concat([this.values.alpha]);\\n  },\\n  alpha: function(val) {\\n    if (val === undefined) {\\n      return this.values.alpha;\\n    }\\n    this.setValues(\\\"alpha\\\", val);\\n    return this;\\n  },\\n\\n  red: function(val) {\\n    return this.setChannel(\\\"rgb\\\", 0, val);\\n  },\\n  green: function(val) {\\n    return this.setChannel(\\\"rgb\\\", 1, val);\\n  },\\n  blue: function(val) {\\n    return this.setChannel(\\\"rgb\\\", 2, val);\\n  },\\n  hue: function(val) {\\n    return this.setChannel(\\\"hsl\\\", 0, val);\\n  },\\n  saturation: function(val) {\\n    return this.setChannel(\\\"hsl\\\", 1, val);\\n  },\\n  lightness: function(val) {\\n    return this.setChannel(\\\"hsl\\\", 2, val);\\n  },\\n  saturationv: function(val) {\\n    return this.setChannel(\\\"hsv\\\", 1, val);\\n  },\\n  whiteness: function(val) {\\n    return this.setChannel(\\\"hwb\\\", 1, val);\\n  },\\n  blackness: function(val) {\\n    return this.setChannel(\\\"hwb\\\", 2, val);\\n  },\\n  value: function(val) {\\n    return this.setChannel(\\\"hsv\\\", 2, val);\\n  },\\n  cyan: function(val) {\\n    return this.setChannel(\\\"cmyk\\\", 0, val);\\n  },\\n  magenta: function(val) {\\n    return this.setChannel(\\\"cmyk\\\", 1, val);\\n  },\\n  yellow: function(val) {\\n    return this.setChannel(\\\"cmyk\\\", 2, val);\\n  },\\n  black: function(val) {\\n    return this.setChannel(\\\"cmyk\\\", 3, val);\\n  },\\n\\n  hexString: function() {\\n    return string.hexString(this.values.rgb);\\n  },\\n  rgbString: function() {\\n    return string.rgbString(this.values.rgb, this.values.alpha);\\n  },\\n  rgbaString: function() {\\n    return string.rgbaString(this.values.rgb, this.values.alpha);\\n  },\\n  percentString: function() {\\n    return string.percentString(this.values.rgb, this.values.alpha);\\n  },\\n  hslString: function() {\\n    return string.hslString(this.values.hsl, this.values.alpha);\\n  },\\n  hslaString: function() {\\n    return string.hslaString(this.values.hsl, this.values.alpha);\\n  },\\n  hwbString: function() {\\n    return string.hwbString(this.values.hwb, this.values.alpha);\\n  },\\n  keyword: function() {\\n    return string.keyword(this.values.rgb, this.values.alpha);\\n  },\\n\\n  rgbNumber: function() {\\n    return (this.values.rgb[0] << 16) | (this.values.rgb[1] << 8) | this.values.rgb[2];\\n  },\\n\\n  luminosity: function() {\\n    // http://www.w3.org/TR/WCAG20/#relativeluminancedef\\n    var rgb = this.values.rgb;\\n    var lum = [];\\n    for (var i = 0; i < rgb.length; i++) {\\n      var chan = rgb[i] / 255;\\n      lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4)\\n    }\\n    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\\n  },\\n\\n  contrast: function(color2) {\\n    // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\\n    var lum1 = this.luminosity();\\n    var lum2 = color2.luminosity();\\n    if (lum1 > lum2) {\\n      return (lum1 + 0.05) / (lum2 + 0.05)\\n    };\\n    return (lum2 + 0.05) / (lum1 + 0.05);\\n  },\\n\\n  level: function(color2) {\\n    var contrastRatio = this.contrast(color2);\\n    return (contrastRatio >= 7.1) ? 'AAA' : (contrastRatio >= 4.5) ? 'AA' : '';\\n  },\\n\\n  dark: function() {\\n    // YIQ equation from http://24ways.org/2010/calculating-color-contrast\\n    var rgb = this.values.rgb,\\n      yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\\n    return yiq < 128;\\n  },\\n\\n  light: function() {\\n    return !this.dark();\\n  },\\n\\n  negate: function() {\\n    var rgb = []\\n    for (var i = 0; i < 3; i++) {\\n      rgb[i] = 255 - this.values.rgb[i];\\n    }\\n    this.setValues(\\\"rgb\\\", rgb);\\n    return this;\\n  },\\n\\n  lighten: function(ratio) {\\n    this.values.hsl[2] += this.values.hsl[2] * ratio;\\n    this.setValues(\\\"hsl\\\", this.values.hsl);\\n    return this;\\n  },\\n\\n  darken: function(ratio) {\\n    this.values.hsl[2] -= this.values.hsl[2] * ratio;\\n    this.setValues(\\\"hsl\\\", this.values.hsl);\\n    return this;\\n  },\\n\\n  saturate: function(ratio) {\\n    this.values.hsl[1] += this.values.hsl[1] * ratio;\\n    this.setValues(\\\"hsl\\\", this.values.hsl);\\n    return this;\\n  },\\n\\n  desaturate: function(ratio) {\\n    this.values.hsl[1] -= this.values.hsl[1] * ratio;\\n    this.setValues(\\\"hsl\\\", this.values.hsl);\\n    return this;\\n  },\\n\\n  whiten: function(ratio) {\\n    this.values.hwb[1] += this.values.hwb[1] * ratio;\\n    this.setValues(\\\"hwb\\\", this.values.hwb);\\n    return this;\\n  },\\n\\n  blacken: function(ratio) {\\n    this.values.hwb[2] += this.values.hwb[2] * ratio;\\n    this.setValues(\\\"hwb\\\", this.values.hwb);\\n    return this;\\n  },\\n\\n  greyscale: function() {\\n    var rgb = this.values.rgb;\\n    // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\\n    var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\\n    this.setValues(\\\"rgb\\\", [val, val, val]);\\n    return this;\\n  },\\n\\n  clearer: function(ratio) {\\n    this.setValues(\\\"alpha\\\", this.values.alpha - (this.values.alpha * ratio));\\n    return this;\\n  },\\n\\n  opaquer: function(ratio) {\\n    this.setValues(\\\"alpha\\\", this.values.alpha + (this.values.alpha * ratio));\\n    return this;\\n  },\\n\\n  rotate: function(degrees) {\\n    var hue = this.values.hsl[0];\\n    hue = (hue + degrees) % 360;\\n    hue = hue < 0 ? 360 + hue : hue;\\n    this.values.hsl[0] = hue;\\n    this.setValues(\\\"hsl\\\", this.values.hsl);\\n    return this;\\n  },\\n\\n  mix: function(color2, weight) {\\n    weight = 1 - (weight == null ? 0.5 : weight);\\n\\n    // algorithm from Sass's mix(). Ratio of first color in mix is\\n    // determined by the alphas of both colors and the weight\\n    var t1 = weight * 2 - 1,\\n      d = this.alpha() - color2.alpha();\\n\\n    var weight1 = (((t1 * d == -1) ? t1 : (t1 + d) / (1 + t1 * d)) + 1) / 2;\\n    var weight2 = 1 - weight1;\\n\\n    var rgb = this.rgbArray();\\n    var rgb2 = color2.rgbArray();\\n\\n    for (var i = 0; i < rgb.length; i++) {\\n      rgb[i] = rgb[i] * weight1 + rgb2[i] * weight2;\\n    }\\n    this.setValues(\\\"rgb\\\", rgb);\\n\\n    var alpha = this.alpha() * weight + color2.alpha() * (1 - weight);\\n    this.setValues(\\\"alpha\\\", alpha);\\n\\n    return this;\\n  },\\n\\n  toJSON: function() {\\n    return this.rgb();\\n  },\\n\\n  clone: function() {\\n    return new Color(this.rgb());\\n  }\\n}\\n\\n\\nColor.prototype.getValues = function(space) {\\n  var vals = {};\\n  for (var i = 0; i < space.length; i++) {\\n    vals[space.charAt(i)] = this.values[space][i];\\n  }\\n  if (this.values.alpha != 1) {\\n    vals[\\\"a\\\"] = this.values.alpha;\\n  }\\n  // {r: 255, g: 255, b: 255, a: 0.4}\\n  return vals;\\n}\\n\\nColor.prototype.setValues = function(space, vals) {\\n  var spaces = {\\n    \\\"rgb\\\": [\\\"red\\\", \\\"green\\\", \\\"blue\\\"],\\n    \\\"hsl\\\": [\\\"hue\\\", \\\"saturation\\\", \\\"lightness\\\"],\\n    \\\"hsv\\\": [\\\"hue\\\", \\\"saturation\\\", \\\"value\\\"],\\n    \\\"hwb\\\": [\\\"hue\\\", \\\"whiteness\\\", \\\"blackness\\\"],\\n    \\\"cmyk\\\": [\\\"cyan\\\", \\\"magenta\\\", \\\"yellow\\\", \\\"black\\\"]\\n  };\\n\\n  var maxes = {\\n    \\\"rgb\\\": [255, 255, 255],\\n    \\\"hsl\\\": [360, 100, 100],\\n    \\\"hsv\\\": [360, 100, 100],\\n    \\\"hwb\\\": [360, 100, 100],\\n    \\\"cmyk\\\": [100, 100, 100, 100]\\n  };\\n\\n  var alpha = 1;\\n  if (space == \\\"alpha\\\") {\\n    alpha = vals;\\n  } else if (vals.length) {\\n    // [10, 10, 10]\\n    this.values[space] = vals.slice(0, space.length);\\n    alpha = vals[space.length];\\n  } else if (vals[space.charAt(0)] !== undefined) {\\n    // {r: 10, g: 10, b: 10}\\n    for (var i = 0; i < space.length; i++) {\\n      this.values[space][i] = vals[space.charAt(i)];\\n    }\\n    alpha = vals.a;\\n  } else if (vals[spaces[space][0]] !== undefined) {\\n    // {red: 10, green: 10, blue: 10}\\n    var chans = spaces[space];\\n    for (var i = 0; i < space.length; i++) {\\n      this.values[space][i] = vals[chans[i]];\\n    }\\n    alpha = vals.alpha;\\n  }\\n  this.values.alpha = Math.max(0, Math.min(1, (alpha !== undefined ? alpha : this.values.alpha)));\\n  if (space == \\\"alpha\\\") {\\n    return;\\n  }\\n\\n  // cap values of the space prior converting all values\\n  for (var i = 0; i < space.length; i++) {\\n    var capped = Math.max(0, Math.min(maxes[space][i], this.values[space][i]));\\n    this.values[space][i] = Math.round(capped);\\n  }\\n\\n  // convert to all the other color spaces\\n  for (var sname in spaces) {\\n    if (sname != space) {\\n      this.values[sname] = convert[space][sname](this.values[space])\\n    }\\n\\n    // cap values\\n    for (var i = 0; i < sname.length; i++) {\\n      var capped = Math.max(0, Math.min(maxes[sname][i], this.values[sname][i]));\\n      this.values[sname][i] = Math.round(capped);\\n    }\\n  }\\n  return true;\\n}\\n\\nColor.prototype.setSpace = function(space, args) {\\n  var vals = args[0];\\n  if (vals === undefined) {\\n    // color.rgb()\\n    return this.getValues(space);\\n  }\\n  // color.rgb(10, 10, 10)\\n  if (typeof vals == \\\"number\\\") {\\n    vals = Array.prototype.slice.call(args);\\n  }\\n  this.setValues(space, vals);\\n  return this;\\n}\\n\\nColor.prototype.setChannel = function(space, index, val) {\\n  if (val === undefined) {\\n    // color.red()\\n    return this.values[space][index];\\n  }\\n  // color.red(100)\\n  this.values[space][index] = val;\\n  this.setValues(space, this.values[space]);\\n  return this;\\n}\\n\\nwindow.Color = module.exports = Color\\n\\n},{\\\"color-convert\\\":3,\\\"color-string\\\":4}],6:[function(require,module,exports){\\nmodule.exports = {\\r\\n\\t\\\"aliceblue\\\": [240, 248, 255],\\r\\n\\t\\\"antiquewhite\\\": [250, 235, 215],\\r\\n\\t\\\"aqua\\\": [0, 255, 255],\\r\\n\\t\\\"aquamarine\\\": [127, 255, 212],\\r\\n\\t\\\"azure\\\": [240, 255, 255],\\r\\n\\t\\\"beige\\\": [245, 245, 220],\\r\\n\\t\\\"bisque\\\": [255, 228, 196],\\r\\n\\t\\\"black\\\": [0, 0, 0],\\r\\n\\t\\\"blanchedalmond\\\": [255, 235, 205],\\r\\n\\t\\\"blue\\\": [0, 0, 255],\\r\\n\\t\\\"blueviolet\\\": [138, 43, 226],\\r\\n\\t\\\"brown\\\": [165, 42, 42],\\r\\n\\t\\\"burlywood\\\": [222, 184, 135],\\r\\n\\t\\\"cadetblue\\\": [95, 158, 160],\\r\\n\\t\\\"chartreuse\\\": [127, 255, 0],\\r\\n\\t\\\"chocolate\\\": [210, 105, 30],\\r\\n\\t\\\"coral\\\": [255, 127, 80],\\r\\n\\t\\\"cornflowerblue\\\": [100, 149, 237],\\r\\n\\t\\\"cornsilk\\\": [255, 248, 220],\\r\\n\\t\\\"crimson\\\": [220, 20, 60],\\r\\n\\t\\\"cyan\\\": [0, 255, 255],\\r\\n\\t\\\"darkblue\\\": [0, 0, 139],\\r\\n\\t\\\"darkcyan\\\": [0, 139, 139],\\r\\n\\t\\\"darkgoldenrod\\\": [184, 134, 11],\\r\\n\\t\\\"darkgray\\\": [169, 169, 169],\\r\\n\\t\\\"darkgreen\\\": [0, 100, 0],\\r\\n\\t\\\"darkgrey\\\": [169, 169, 169],\\r\\n\\t\\\"darkkhaki\\\": [189, 183, 107],\\r\\n\\t\\\"darkmagenta\\\": [139, 0, 139],\\r\\n\\t\\\"darkolivegreen\\\": [85, 107, 47],\\r\\n\\t\\\"darkorange\\\": [255, 140, 0],\\r\\n\\t\\\"darkorchid\\\": [153, 50, 204],\\r\\n\\t\\\"darkred\\\": [139, 0, 0],\\r\\n\\t\\\"darksalmon\\\": [233, 150, 122],\\r\\n\\t\\\"darkseagreen\\\": [143, 188, 143],\\r\\n\\t\\\"darkslateblue\\\": [72, 61, 139],\\r\\n\\t\\\"darkslategray\\\": [47, 79, 79],\\r\\n\\t\\\"darkslategrey\\\": [47, 79, 79],\\r\\n\\t\\\"darkturquoise\\\": [0, 206, 209],\\r\\n\\t\\\"darkviolet\\\": [148, 0, 211],\\r\\n\\t\\\"deeppink\\\": [255, 20, 147],\\r\\n\\t\\\"deepskyblue\\\": [0, 191, 255],\\r\\n\\t\\\"dimgray\\\": [105, 105, 105],\\r\\n\\t\\\"dimgrey\\\": [105, 105, 105],\\r\\n\\t\\\"dodgerblue\\\": [30, 144, 255],\\r\\n\\t\\\"firebrick\\\": [178, 34, 34],\\r\\n\\t\\\"floralwhite\\\": [255, 250, 240],\\r\\n\\t\\\"forestgreen\\\": [34, 139, 34],\\r\\n\\t\\\"fuchsia\\\": [255, 0, 255],\\r\\n\\t\\\"gainsboro\\\": [220, 220, 220],\\r\\n\\t\\\"ghostwhite\\\": [248, 248, 255],\\r\\n\\t\\\"gold\\\": [255, 215, 0],\\r\\n\\t\\\"goldenrod\\\": [218, 165, 32],\\r\\n\\t\\\"gray\\\": [128, 128, 128],\\r\\n\\t\\\"green\\\": [0, 128, 0],\\r\\n\\t\\\"greenyellow\\\": [173, 255, 47],\\r\\n\\t\\\"grey\\\": [128, 128, 128],\\r\\n\\t\\\"honeydew\\\": [240, 255, 240],\\r\\n\\t\\\"hotpink\\\": [255, 105, 180],\\r\\n\\t\\\"indianred\\\": [205, 92, 92],\\r\\n\\t\\\"indigo\\\": [75, 0, 130],\\r\\n\\t\\\"ivory\\\": [255, 255, 240],\\r\\n\\t\\\"khaki\\\": [240, 230, 140],\\r\\n\\t\\\"lavender\\\": [230, 230, 250],\\r\\n\\t\\\"lavenderblush\\\": [255, 240, 245],\\r\\n\\t\\\"lawngreen\\\": [124, 252, 0],\\r\\n\\t\\\"lemonchiffon\\\": [255, 250, 205],\\r\\n\\t\\\"lightblue\\\": [173, 216, 230],\\r\\n\\t\\\"lightcoral\\\": [240, 128, 128],\\r\\n\\t\\\"lightcyan\\\": [224, 255, 255],\\r\\n\\t\\\"lightgoldenrodyellow\\\": [250, 250, 210],\\r\\n\\t\\\"lightgray\\\": [211, 211, 211],\\r\\n\\t\\\"lightgreen\\\": [144, 238, 144],\\r\\n\\t\\\"lightgrey\\\": [211, 211, 211],\\r\\n\\t\\\"lightpink\\\": [255, 182, 193],\\r\\n\\t\\\"lightsalmon\\\": [255, 160, 122],\\r\\n\\t\\\"lightseagreen\\\": [32, 178, 170],\\r\\n\\t\\\"lightskyblue\\\": [135, 206, 250],\\r\\n\\t\\\"lightslategray\\\": [119, 136, 153],\\r\\n\\t\\\"lightslategrey\\\": [119, 136, 153],\\r\\n\\t\\\"lightsteelblue\\\": [176, 196, 222],\\r\\n\\t\\\"lightyellow\\\": [255, 255, 224],\\r\\n\\t\\\"lime\\\": [0, 255, 0],\\r\\n\\t\\\"limegreen\\\": [50, 205, 50],\\r\\n\\t\\\"linen\\\": [250, 240, 230],\\r\\n\\t\\\"magenta\\\": [255, 0, 255],\\r\\n\\t\\\"maroon\\\": [128, 0, 0],\\r\\n\\t\\\"mediumaquamarine\\\": [102, 205, 170],\\r\\n\\t\\\"mediumblue\\\": [0, 0, 205],\\r\\n\\t\\\"mediumorchid\\\": [186, 85, 211],\\r\\n\\t\\\"mediumpurple\\\": [147, 112, 219],\\r\\n\\t\\\"mediumseagreen\\\": [60, 179, 113],\\r\\n\\t\\\"mediumslateblue\\\": [123, 104, 238],\\r\\n\\t\\\"mediumspringgreen\\\": [0, 250, 154],\\r\\n\\t\\\"mediumturquoise\\\": [72, 209, 204],\\r\\n\\t\\\"mediumvioletred\\\": [199, 21, 133],\\r\\n\\t\\\"midnightblue\\\": [25, 25, 112],\\r\\n\\t\\\"mintcream\\\": [245, 255, 250],\\r\\n\\t\\\"mistyrose\\\": [255, 228, 225],\\r\\n\\t\\\"moccasin\\\": [255, 228, 181],\\r\\n\\t\\\"navajowhite\\\": [255, 222, 173],\\r\\n\\t\\\"navy\\\": [0, 0, 128],\\r\\n\\t\\\"oldlace\\\": [253, 245, 230],\\r\\n\\t\\\"olive\\\": [128, 128, 0],\\r\\n\\t\\\"olivedrab\\\": [107, 142, 35],\\r\\n\\t\\\"orange\\\": [255, 165, 0],\\r\\n\\t\\\"orangered\\\": [255, 69, 0],\\r\\n\\t\\\"orchid\\\": [218, 112, 214],\\r\\n\\t\\\"palegoldenrod\\\": [238, 232, 170],\\r\\n\\t\\\"palegreen\\\": [152, 251, 152],\\r\\n\\t\\\"paleturquoise\\\": [175, 238, 238],\\r\\n\\t\\\"palevioletred\\\": [219, 112, 147],\\r\\n\\t\\\"papayawhip\\\": [255, 239, 213],\\r\\n\\t\\\"peachpuff\\\": [255, 218, 185],\\r\\n\\t\\\"peru\\\": [205, 133, 63],\\r\\n\\t\\\"pink\\\": [255, 192, 203],\\r\\n\\t\\\"plum\\\": [221, 160, 221],\\r\\n\\t\\\"powderblue\\\": [176, 224, 230],\\r\\n\\t\\\"purple\\\": [128, 0, 128],\\r\\n\\t\\\"rebeccapurple\\\": [102, 51, 153],\\r\\n\\t\\\"red\\\": [255, 0, 0],\\r\\n\\t\\\"rosybrown\\\": [188, 143, 143],\\r\\n\\t\\\"royalblue\\\": [65, 105, 225],\\r\\n\\t\\\"saddlebrown\\\": [139, 69, 19],\\r\\n\\t\\\"salmon\\\": [250, 128, 114],\\r\\n\\t\\\"sandybrown\\\": [244, 164, 96],\\r\\n\\t\\\"seagreen\\\": [46, 139, 87],\\r\\n\\t\\\"seashell\\\": [255, 245, 238],\\r\\n\\t\\\"sienna\\\": [160, 82, 45],\\r\\n\\t\\\"silver\\\": [192, 192, 192],\\r\\n\\t\\\"skyblue\\\": [135, 206, 235],\\r\\n\\t\\\"slateblue\\\": [106, 90, 205],\\r\\n\\t\\\"slategray\\\": [112, 128, 144],\\r\\n\\t\\\"slategrey\\\": [112, 128, 144],\\r\\n\\t\\\"snow\\\": [255, 250, 250],\\r\\n\\t\\\"springgreen\\\": [0, 255, 127],\\r\\n\\t\\\"steelblue\\\": [70, 130, 180],\\r\\n\\t\\\"tan\\\": [210, 180, 140],\\r\\n\\t\\\"teal\\\": [0, 128, 128],\\r\\n\\t\\\"thistle\\\": [216, 191, 216],\\r\\n\\t\\\"tomato\\\": [255, 99, 71],\\r\\n\\t\\\"turquoise\\\": [64, 224, 208],\\r\\n\\t\\\"violet\\\": [238, 130, 238],\\r\\n\\t\\\"wheat\\\": [245, 222, 179],\\r\\n\\t\\\"white\\\": [255, 255, 255],\\r\\n\\t\\\"whitesmoke\\\": [245, 245, 245],\\r\\n\\t\\\"yellow\\\": [255, 255, 0],\\r\\n\\t\\\"yellowgreen\\\": [154, 205, 50]\\r\\n};\\n},{}],7:[function(require,module,exports){\\n/*!\\n * Chart.js\\n * http://chartjs.org/\\n * Version: 2.0.0\\n *\\n * Copyright 2015 Nick Downie\\n * Released under the MIT license\\n * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md\\n */\\n\\n\\nvar Chart = require('./core/core.js')();\\n\\nrequire('./core/core.helpers')(Chart);\\nrequire('./core/core.element')(Chart);\\nrequire('./core/core.animation')(Chart);\\nrequire('./core/core.controller')(Chart);\\nrequire('./core/core.datasetController')(Chart);\\nrequire('./core/core.layoutService')(Chart);\\nrequire('./core/core.legend')(Chart);\\nrequire('./core/core.scale')(Chart);\\nrequire('./core/core.scaleService')(Chart);\\nrequire('./core/core.title')(Chart);\\nrequire('./core/core.tooltip')(Chart);\\n\\nrequire('./controllers/controller.bar')(Chart);\\nrequire('./controllers/controller.bubble')(Chart);\\nrequire('./controllers/controller.doughnut')(Chart);\\nrequire('./controllers/controller.line')(Chart);\\nrequire('./controllers/controller.polarArea')(Chart);\\nrequire('./controllers/controller.radar')(Chart);\\n\\nrequire('./scales/scale.category')(Chart);\\nrequire('./scales/scale.linear')(Chart);\\nrequire('./scales/scale.logarithmic')(Chart);\\nrequire('./scales/scale.radialLinear')(Chart);\\nrequire('./scales/scale.time')(Chart);\\n\\nrequire('./elements/element.arc')(Chart);\\nrequire('./elements/element.line')(Chart);\\nrequire('./elements/element.point')(Chart);\\nrequire('./elements/element.rectangle')(Chart);\\n\\nrequire('./charts/Chart.Bar')(Chart);\\nrequire('./charts/Chart.Bubble')(Chart);\\nrequire('./charts/Chart.Doughnut')(Chart);\\nrequire('./charts/Chart.Line')(Chart);\\nrequire('./charts/Chart.PolarArea')(Chart);\\nrequire('./charts/Chart.Radar')(Chart);\\nrequire('./charts/Chart.Scatter')(Chart);\\n\\nwindow.Chart = module.exports = Chart;\\n\\n},{\\\"./charts/Chart.Bar\\\":8,\\\"./charts/Chart.Bubble\\\":9,\\\"./charts/Chart.Doughnut\\\":10,\\\"./charts/Chart.Line\\\":11,\\\"./charts/Chart.PolarArea\\\":12,\\\"./charts/Chart.Radar\\\":13,\\\"./charts/Chart.Scatter\\\":14,\\\"./controllers/controller.bar\\\":15,\\\"./controllers/controller.bubble\\\":16,\\\"./controllers/controller.doughnut\\\":17,\\\"./controllers/controller.line\\\":18,\\\"./controllers/controller.polarArea\\\":19,\\\"./controllers/controller.radar\\\":20,\\\"./core/core.animation\\\":21,\\\"./core/core.controller\\\":22,\\\"./core/core.datasetController\\\":23,\\\"./core/core.element\\\":24,\\\"./core/core.helpers\\\":25,\\\"./core/core.js\\\":26,\\\"./core/core.layoutService\\\":27,\\\"./core/core.legend\\\":28,\\\"./core/core.scale\\\":29,\\\"./core/core.scaleService\\\":30,\\\"./core/core.title\\\":31,\\\"./core/core.tooltip\\\":32,\\\"./elements/element.arc\\\":33,\\\"./elements/element.line\\\":34,\\\"./elements/element.point\\\":35,\\\"./elements/element.rectangle\\\":36,\\\"./scales/scale.category\\\":37,\\\"./scales/scale.linear\\\":38,\\\"./scales/scale.logarithmic\\\":39,\\\"./scales/scale.radialLinear\\\":40,\\\"./scales/scale.time\\\":41}],8:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Bar = function(context, config) {\\n\\t\\tconfig.type = 'bar';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n},{}],9:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Bubble = function(context, config) {\\n\\t\\tconfig.type = 'bubble';\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n},{}],10:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Doughnut = function(context, config) {\\n\\t\\tconfig.type = 'doughnut';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n},{}],11:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Line = function(context, config) {\\n\\t\\tconfig.type = 'line';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n},{}],12:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.PolarArea = function(context, config) {\\n\\t\\tconfig.type = 'polarArea';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n},{}],13:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tvar defaultConfig = {\\n\\t\\taspectRatio: 1\\n\\t};\\n\\n\\tChart.Radar = function(context, config) {\\n\\t\\tconfig.options = helpers.configMerge(defaultConfig, config.options);\\n\\t\\tconfig.type = 'radar';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],14:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar defaultConfig = {\\n\\t\\thover: {\\n\\t\\t\\tmode: 'single'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: \\\"linear\\\", // scatter should not use a category axis\\n\\t\\t\\t\\tposition: \\\"bottom\\\",\\n\\t\\t\\t\\tid: \\\"x-axis-1\\\" // need an ID so datasets can reference the scale\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: \\\"linear\\\",\\n\\t\\t\\t\\tposition: \\\"left\\\",\\n\\t\\t\\t\\tid: \\\"y-axis-1\\\"\\n\\t\\t\\t}]\\n\\t\\t},\\n\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function(tooltipItems, data) {\\n\\t\\t\\t\\t\\t// Title doesn't make sense for scatter since we format the data as a point\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\treturn '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t// Register the default config for this type\\n\\tChart.defaults.scatter = defaultConfig;\\n\\n\\t// Scatter charts use line controllers\\n\\tChart.controllers.scatter = Chart.controllers.line;\\n\\n\\tChart.Scatter = function(context, config) {\\n\\t\\tconfig.type = 'scatter';\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n},{}],15:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.bar = {\\n\\t\\thover: {\\n\\t\\t\\tmode: \\\"label\\\"\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: \\\"category\\\",\\n\\n\\t\\t\\t\\t// Specific to Bar Controller\\n\\t\\t\\t\\tcategoryPercentage: 0.8,\\n\\t\\t\\t\\tbarPercentage: 0.9,\\n\\n\\t\\t\\t\\t// grid line settings\\n\\t\\t\\t\\tgridLines: {\\n\\t\\t\\t\\t\\toffsetGridLines: true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: \\\"linear\\\"\\n\\t\\t\\t}]\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.bar = Chart.DatasetController.extend({\\n\\t\\tinitialize: function(chart, datasetIndex) {\\n\\t\\t\\tChart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);\\n\\n\\t\\t\\t// Use this to indicate that this is a bar dataset.\\n\\t\\t\\tthis.getDataset().bar = true;\\n\\t\\t},\\n\\t\\t// Get the number of datasets that display bars. We use this to correctly calculate the bar width\\n\\t\\tgetBarCount: function getBarCount() {\\n\\t\\t\\tvar barCount = 0;\\n\\t\\t\\thelpers.each(this.chart.data.datasets, function(dataset) {\\n\\t\\t\\t\\tif (helpers.isDatasetVisible(dataset) && dataset.bar) {\\n\\t\\t\\t\\t\\t++barCount;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn barCount;\\n\\t\\t},\\n\\n\\t\\taddElements: function() {\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\t\\t\\thelpers.each(this.getDataset().data, function(value, index) {\\n\\t\\t\\t\\tthis.getDataset().metaData[index] = this.getDataset().metaData[index] || new Chart.elements.Rectangle({\\n\\t\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t\\t_index: index\\n\\t\\t\\t\\t});\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\t\\taddElementAndReset: function(index) {\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\t\\t\\tvar rectangle = new Chart.elements.Rectangle({\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index\\n\\t\\t\\t});\\n\\n\\t\\t\\tvar numBars = this.getBarCount();\\n\\n\\t\\t\\tthis.updateElement(rectangle, index, true, numBars);\\n\\t\\t\\tthis.getDataset().metaData.splice(index, 0, rectangle);\\n\\t\\t},\\n\\n\\t\\tupdate: function update(reset) {\\n\\t\\t\\tvar numBars = this.getBarCount();\\n\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(rectangle, index) {\\n\\t\\t\\t\\tthis.updateElement(rectangle, index, reset, numBars);\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\n\\t\\tupdateElement: function updateElement(rectangle, index, reset, numBars) {\\n\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar yScale = this.getScaleForId(this.getDataset().yAxisID);\\n\\n\\t\\t\\tvar yScalePoint;\\n\\n\\t\\t\\tif (yScale.min < 0 && yScale.max < 0) {\\n\\t\\t\\t\\t// all less than 0. use the top\\n\\t\\t\\t\\tyScalePoint = yScale.getPixelForValue(yScale.max);\\n\\t\\t\\t} else if (yScale.min > 0 && yScale.max > 0) {\\n\\t\\t\\t\\tyScalePoint = yScale.getPixelForValue(yScale.min);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tyScalePoint = yScale.getPixelForValue(0);\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.extend(rectangle, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_xScale: xScale,\\n\\t\\t\\t\\t_yScale: yScale,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index,\\n\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: this.calculateBarX(index, this.index),\\n\\t\\t\\t\\t\\ty: reset ? yScalePoint : this.calculateBarY(index, this.index),\\n\\n\\t\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\t\\tlabel: this.chart.data.labels[index],\\n\\t\\t\\t\\t\\tdatasetLabel: this.getDataset().label,\\n\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\tbase: reset ? yScalePoint : this.calculateBarBase(this.index, index),\\n\\t\\t\\t\\t\\twidth: this.calculateBarWidth(numBars),\\n\\t\\t\\t\\t\\tbackgroundColor: rectangle.custom && rectangle.custom.backgroundColor ? rectangle.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.rectangle.backgroundColor),\\n\\t\\t\\t\\t\\tborderSkipped: rectangle.custom && rectangle.custom.borderSkipped ? rectangle.custom.borderSkipped : this.chart.options.elements.rectangle.borderSkipped,\\n\\t\\t\\t\\t\\tborderColor: rectangle.custom && rectangle.custom.borderColor ? rectangle.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.rectangle.borderColor),\\n\\t\\t\\t\\t\\tborderWidth: rectangle.custom && rectangle.custom.borderWidth ? rectangle.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.rectangle.borderWidth)\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\trectangle.pivot();\\n\\t\\t},\\n\\n\\t\\tcalculateBarBase: function(datasetIndex, index) {\\n\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar yScale = this.getScaleForId(this.getDataset().yAxisID);\\n\\n\\t\\t\\tvar base = 0;\\n\\n\\t\\t\\tif (yScale.options.stacked) {\\n\\n\\t\\t\\t\\tvar value = this.chart.data.datasets[datasetIndex].data[index];\\n\\n\\t\\t\\t\\tif (value < 0) {\\n\\t\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\t\\tvar negDS = this.chart.data.datasets[i];\\n\\t\\t\\t\\t\\t\\tif (helpers.isDatasetVisible(negDS) && negDS.yAxisID === yScale.id && negDS.bar) {\\n\\t\\t\\t\\t\\t\\t\\tbase += negDS.data[index] < 0 ? negDS.data[index] : 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfor (var j = 0; j < datasetIndex; j++) {\\n\\t\\t\\t\\t\\t\\tvar posDS = this.chart.data.datasets[j];\\n\\t\\t\\t\\t\\t\\tif (helpers.isDatasetVisible(posDS) && posDS.yAxisID === yScale.id && posDS.bar) {\\n\\t\\t\\t\\t\\t\\t\\tbase += posDS.data[index] > 0 ? posDS.data[index] : 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn yScale.getPixelForValue(base);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbase = yScale.getPixelForValue(yScale.min);\\n\\n\\t\\t\\tif (yScale.beginAtZero || ((yScale.min <= 0 && yScale.max >= 0) || (yScale.min >= 0 && yScale.max <= 0))) {\\n\\t\\t\\t\\tbase = yScale.getPixelForValue(0, 0);\\n\\t\\t\\t\\t//base += yScale.options.gridLines.lineWidth;\\n\\t\\t\\t} else if (yScale.min < 0 && yScale.max < 0) {\\n\\t\\t\\t\\t// All values are negative. Use the top as the base\\n\\t\\t\\t\\tbase = yScale.getPixelForValue(yScale.max);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn base;\\n\\n\\t\\t},\\n\\n\\t\\tgetRuler: function() {\\n\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar yScale = this.getScaleForId(this.getDataset().yAxisID);\\n\\t\\t\\tvar datasetCount = this.getBarCount();\\n\\n\\t\\t\\tvar tickWidth = (function() {\\n\\t\\t\\t\\tvar min = xScale.getPixelForTick(1) - xScale.getPixelForTick(0);\\n\\t\\t\\t\\tfor (var i = 2; i < this.getDataset().data.length; i++) {\\n\\t\\t\\t\\t\\tmin = Math.min(xScale.getPixelForTick(i) - xScale.getPixelForTick(i - 1), min);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn min;\\n\\t\\t\\t}).call(this);\\n\\t\\t\\tvar categoryWidth = tickWidth * xScale.options.categoryPercentage;\\n\\t\\t\\tvar categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2;\\n\\t\\t\\tvar fullBarWidth = categoryWidth / datasetCount;\\n\\t\\t\\tvar barWidth = fullBarWidth * xScale.options.barPercentage;\\n\\t\\t\\tvar barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage);\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tdatasetCount: datasetCount,\\n\\t\\t\\t\\ttickWidth: tickWidth,\\n\\t\\t\\t\\tcategoryWidth: categoryWidth,\\n\\t\\t\\t\\tcategorySpacing: categorySpacing,\\n\\t\\t\\t\\tfullBarWidth: fullBarWidth,\\n\\t\\t\\t\\tbarWidth: barWidth,\\n\\t\\t\\t\\tbarSpacing: barSpacing\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\tcalculateBarWidth: function() {\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar ruler = this.getRuler();\\n\\t\\t\\treturn xScale.options.stacked ? ruler.categoryWidth : ruler.barWidth;\\n\\t\\t},\\n\\n\\t\\t// Get bar index from the given dataset index accounting for the fact that not all bars are visible\\n\\t\\tgetBarIndex: function(datasetIndex) {\\n\\t\\t\\tvar barIndex = 0;\\n\\n\\t\\t\\tfor (var j = 0; j < datasetIndex; ++j) {\\n\\t\\t\\t\\tif (helpers.isDatasetVisible(this.chart.data.datasets[j]) && this.chart.data.datasets[j].bar) {\\n\\t\\t\\t\\t\\t++barIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn barIndex;\\n\\t\\t},\\n\\n\\t\\tcalculateBarX: function(index, datasetIndex) {\\n\\n\\t\\t\\tvar yScale = this.getScaleForId(this.getDataset().yAxisID);\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar barIndex = this.getBarIndex(datasetIndex);\\n\\n\\t\\t\\tvar ruler = this.getRuler();\\n\\t\\t\\tvar leftTick = xScale.getPixelForValue(null, index, datasetIndex, this.chart.isCombo);\\n\\t\\t\\tleftTick -= this.chart.isCombo ? (ruler.tickWidth / 2) : 0;\\n\\n\\t\\t\\tif (xScale.options.stacked) {\\n\\t\\t\\t\\treturn leftTick + (ruler.categoryWidth / 2) + ruler.categorySpacing;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn leftTick +\\n\\t\\t\\t\\t(ruler.barWidth / 2) +\\n\\t\\t\\t\\truler.categorySpacing +\\n\\t\\t\\t\\t(ruler.barWidth * barIndex) +\\n\\t\\t\\t\\t(ruler.barSpacing / 2) +\\n\\t\\t\\t\\t(ruler.barSpacing * barIndex);\\n\\t\\t},\\n\\n\\t\\tcalculateBarY: function(index, datasetIndex) {\\n\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar yScale = this.getScaleForId(this.getDataset().yAxisID);\\n\\n\\t\\t\\tvar value = this.getDataset().data[index];\\n\\n\\t\\t\\tif (yScale.options.stacked) {\\n\\n\\t\\t\\t\\tvar sumPos = 0,\\n\\t\\t\\t\\t\\tsumNeg = 0;\\n\\n\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tvar ds = this.chart.data.datasets[i];\\n\\t\\t\\t\\t\\tif (helpers.isDatasetVisible(ds) && ds.bar && ds.yAxisID === yScale.id) {\\n\\t\\t\\t\\t\\t\\tif (ds.data[index] < 0) {\\n\\t\\t\\t\\t\\t\\t\\tsumNeg += ds.data[index] || 0;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsumPos += ds.data[index] || 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (value < 0) {\\n\\t\\t\\t\\t\\treturn yScale.getPixelForValue(sumNeg + value);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn yScale.getPixelForValue(sumPos + value);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn yScale.getPixelForValue(value);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn yScale.getPixelForValue(value);\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(rectangle, index) {\\n\\t\\t\\t\\tvar d = this.getDataset().data[index];\\n\\t\\t\\t\\tif (d !== null && d !== undefined && !isNaN(d)) {\\n\\t\\t\\t\\t\\trectangle.transition(easingDecimal).draw();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(rectangle) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\\n\\t\\t\\tvar index = rectangle._index;\\n\\n\\t\\t\\trectangle._model.backgroundColor = rectangle.custom && rectangle.custom.hoverBackgroundColor ? rectangle.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.color(rectangle._model.backgroundColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\trectangle._model.borderColor = rectangle.custom && rectangle.custom.hoverBorderColor ? rectangle.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.color(rectangle._model.borderColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\trectangle._model.borderWidth = rectangle.custom && rectangle.custom.hoverBorderWidth ? rectangle.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, rectangle._model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(rectangle) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\\n\\t\\t\\tvar index = rectangle._index;\\n\\n\\t\\t\\trectangle._model.backgroundColor = rectangle.custom && rectangle.custom.backgroundColor ? rectangle.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.rectangle.backgroundColor);\\n\\t\\t\\trectangle._model.borderColor = rectangle.custom && rectangle.custom.borderColor ? rectangle.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.rectangle.borderColor);\\n\\t\\t\\trectangle._model.borderWidth = rectangle.custom && rectangle.custom.borderWidth ? rectangle.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.rectangle.borderWidth);\\n\\t\\t}\\n\\n\\t});\\n};\\n\\n},{}],16:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.bubble = {\\n\\t\\thover: {\\n\\t\\t\\tmode: \\\"single\\\"\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: \\\"linear\\\", // bubble should probably use a linear scale by default\\n\\t\\t\\t\\tposition: \\\"bottom\\\",\\n\\t\\t\\t\\tid: \\\"x-axis-0\\\" // need an ID so datasets can reference the scale\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: \\\"linear\\\",\\n\\t\\t\\t\\tposition: \\\"left\\\",\\n\\t\\t\\t\\tid: \\\"y-axis-0\\\"\\n\\t\\t\\t}]\\n\\t\\t},\\n\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function(tooltipItems, data) {\\n\\t\\t\\t\\t\\t// Title doesn't make sense for scatter since we format the data as a point\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\\n\\t\\t\\t\\t\\tvar dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\\n\\t\\t\\t\\t\\treturn datasetLabel + ': (' + dataPoint.x + ', ' + dataPoint.y + ', ' + dataPoint.r + ')';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\n\\tChart.controllers.bubble = Chart.DatasetController.extend({\\n\\t\\taddElements: function() {\\n\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\n\\t\\t\\thelpers.each(this.getDataset().data, function(value, index) {\\n\\t\\t\\t\\tthis.getDataset().metaData[index] = this.getDataset().metaData[index] || new Chart.elements.Point({\\n\\t\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t\\t_index: index\\n\\t\\t\\t\\t});\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\t\\taddElementAndReset: function(index) {\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\t\\t\\tvar point = new Chart.elements.Point({\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Reset the point\\n\\t\\t\\tthis.updateElement(point, index, true);\\n\\n\\t\\t\\t// Add to the points array\\n\\t\\t\\tthis.getDataset().metaData.splice(index, 0, point);\\n\\t\\t},\\n\\n\\t\\tupdate: function update(reset) {\\n\\t\\t\\tvar points = this.getDataset().metaData;\\n\\n\\t\\t\\tvar yScale = this.getScaleForId(this.getDataset().yAxisID);\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar scaleBase;\\n\\n\\t\\t\\tif (yScale.min < 0 && yScale.max < 0) {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(yScale.max);\\n\\t\\t\\t} else if (yScale.min > 0 && yScale.max > 0) {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(yScale.min);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(0);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update Points\\n\\t\\t\\thelpers.each(points, function(point, index) {\\n\\t\\t\\t\\tthis.updateElement(point, index, reset);\\n\\t\\t\\t}, this);\\n\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(point, index, reset) {\\n\\t\\t\\tvar yScale = this.getScaleForId(this.getDataset().yAxisID);\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar scaleBase;\\n\\n\\t\\t\\tif (yScale.min < 0 && yScale.max < 0) {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(yScale.max);\\n\\t\\t\\t} else if (yScale.min > 0 && yScale.max > 0) {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(yScale.min);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(0);\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.extend(point, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_xScale: xScale,\\n\\t\\t\\t\\t_yScale: yScale,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(this.getDataset().data[index], index, this.index, this.chart.isCombo),\\n\\t\\t\\t\\t\\ty: reset ? scaleBase : yScale.getPixelForValue(this.getDataset().data[index], index, this.index),\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\tradius: reset ? 0 : point.custom && point.custom.radius ? point.custom.radius : this.getRadius(this.getDataset().data[index]),\\n\\t\\t\\t\\t\\tbackgroundColor: point.custom && point.custom.backgroundColor ? point.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.point.backgroundColor),\\n\\t\\t\\t\\t\\tborderColor: point.custom && point.custom.borderColor ? point.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.point.borderColor),\\n\\t\\t\\t\\t\\tborderWidth: point.custom && point.custom.borderWidth ? point.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.point.borderWidth),\\n\\n\\t\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\t\\thitRadius: point.custom && point.custom.hitRadius ? point.custom.hitRadius : helpers.getValueAtIndexOrDefault(this.getDataset().hitRadius, index, this.chart.options.elements.point.hitRadius)\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tpoint._model.skip = point.custom && point.custom.skip ? point.custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\\n\\n\\t\\t\\tpoint.pivot();\\n\\t\\t},\\n\\n\\t\\tgetRadius: function(value) {\\n\\t\\t\\treturn value.r || this.chart.options.elements.point.radius;\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\n\\t\\t\\t// Transition and Draw the Points\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(point, index) {\\n\\t\\t\\t\\tpoint.transition(easingDecimal);\\n\\t\\t\\t\\tpoint.draw();\\n\\t\\t\\t});\\n\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(point) {\\n\\t\\t\\t// Point\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\n\\t\\t\\tpoint._model.radius = point.custom && point.custom.hoverRadius ? point.custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, this.chart.options.elements.point.hoverRadius)) + this.getRadius(this.getDataset().data[point._index]);\\n\\t\\t\\tpoint._model.backgroundColor = point.custom && point.custom.hoverBackgroundColor ? point.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.color(point._model.backgroundColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\tpoint._model.borderColor = point.custom && point.custom.hoverBorderColor ? point.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.color(point._model.borderColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\tpoint._model.borderWidth = point.custom && point.custom.hoverBorderWidth ? point.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, point._model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(point) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\n\\t\\t\\tpoint._model.radius = point.custom && point.custom.radius ? point.custom.radius : this.getRadius(this.getDataset().data[point._index]);\\n\\t\\t\\tpoint._model.backgroundColor = point.custom && point.custom.backgroundColor ? point.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.point.backgroundColor);\\n\\t\\t\\tpoint._model.borderColor = point.custom && point.custom.borderColor ? point.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.point.borderColor);\\n\\t\\t\\tpoint._model.borderWidth = point.custom && point.custom.borderWidth ? point.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.point.borderWidth);\\n\\t\\t}\\n\\t});\\n};\\n},{}],17:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.doughnut = {\\n\\t\\tanimation: {\\n\\t\\t\\t//Boolean - Whether we animate the rotation of the Doughnut\\n\\t\\t\\tanimateRotate: true,\\n\\t\\t\\t//Boolean - Whether we animate scaling the Doughnut from the centre\\n\\t\\t\\tanimateScale: false\\n\\t\\t},\\n\\t\\taspectRatio: 1,\\n\\t\\thover: {\\n\\t\\t\\tmode: 'single'\\n\\t\\t},\\n\\t\\tlegendCallback: function(chart) {\\n\\t\\t\\tvar text = [];\\n\\t\\t\\ttext.push('<ul class=\\\"' + chart.id + '-legend\\\">');\\n\\n\\t\\t\\tif (chart.data.datasets.length) {\\n\\t\\t\\t\\tfor (var i = 0; i < chart.data.datasets[0].data.length; ++i) {\\n\\t\\t\\t\\t\\ttext.push('<li><span style=\\\"background-color:' + chart.data.datasets[0].backgroundColor[i] + '\\\">');\\n\\t\\t\\t\\t\\tif (chart.data.labels[i]) {\\n\\t\\t\\t\\t\\t\\ttext.push(chart.data.labels[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttext.push('</span></li>');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\ttext.push('</ul>');\\n\\t\\t\\treturn text.join(\\\"\\\");\\n\\t\\t},\\n\\t\\tlegend: {\\n\\t\\t\\tlabels: {\\n\\t\\t\\t\\tgenerateLabels: function(data) {\\n\\t\\t\\t\\t\\tif (data.labels.length && data.datasets.length) {\\n\\t\\t\\t\\t\\t\\treturn data.labels.map(function(label, i) {\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\ttext: label,\\n\\t\\t\\t\\t\\t\\t\\t\\tfillStyle: data.datasets[0].backgroundColor[i],\\n\\t\\t\\t\\t\\t\\t\\t\\thidden: isNaN(data.datasets[0].data[i]),\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Extra data used for toggling the correct item\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn [];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tonClick: function(e, legendItem) {\\n\\t\\t\\t\\thelpers.each(this.chart.data.datasets, function(dataset) {\\n\\t\\t\\t\\t\\tdataset.metaHiddenData = dataset.metaHiddenData || [];\\n\\t\\t\\t\\t\\tvar idx = legendItem.index;\\n\\n\\t\\t\\t\\t\\tif (!isNaN(dataset.data[idx])) {\\n\\t\\t\\t\\t\\t\\tdataset.metaHiddenData[idx] = dataset.data[idx];\\n\\t\\t\\t\\t\\t\\tdataset.data[idx] = NaN;\\n\\t\\t\\t\\t\\t} else if (!isNaN(dataset.metaHiddenData[idx])) {\\n\\t\\t\\t\\t\\t\\tdataset.data[idx] = dataset.metaHiddenData[idx];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tthis.chart.update();\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t//The percentage of the chart that we cut out of the middle.\\n\\t\\tcutoutPercentage: 50,\\n\\n\\t\\t// Need to override these to give a nice default\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function() {\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\treturn data.labels[tooltipItem.index] + ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.defaults.pie = helpers.clone(Chart.defaults.doughnut);\\n\\thelpers.extend(Chart.defaults.pie, {\\n\\t\\tcutoutPercentage: 0\\n\\t});\\n\\n\\n\\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\\n\\t\\tlinkScales: function() {\\n\\t\\t\\t// no scales for doughnut\\n\\t\\t},\\n\\n\\t\\taddElements: function() {\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\t\\t\\thelpers.each(this.getDataset().data, function(value, index) {\\n\\t\\t\\t\\tthis.getDataset().metaData[index] = this.getDataset().metaData[index] || new Chart.elements.Arc({\\n\\t\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t\\t_index: index\\n\\t\\t\\t\\t});\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\t\\taddElementAndReset: function(index, colorForNewElement) {\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\t\\t\\tvar arc = new Chart.elements.Arc({\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (colorForNewElement && helpers.isArray(this.getDataset().backgroundColor)) {\\n\\t\\t\\t\\tthis.getDataset().backgroundColor.splice(index, 0, colorForNewElement);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reset the point\\n\\t\\t\\tthis.updateElement(arc, index, true);\\n\\n\\t\\t\\t// Add to the points array\\n\\t\\t\\tthis.getDataset().metaData.splice(index, 0, arc);\\n\\t\\t},\\n\\n\\t\\tgetVisibleDatasetCount: function getVisibleDatasetCount() {\\n\\t\\t\\treturn helpers.where(this.chart.data.datasets, function(ds) {\\n\\t\\t\\t\\treturn helpers.isDatasetVisible(ds);\\n\\t\\t\\t}).length;\\n\\t\\t},\\n\\n\\t\\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\\n\\t\\tgetRingIndex: function getRingIndex(datasetIndex) {\\n\\t\\t\\tvar ringIndex = 0;\\n\\n\\t\\t\\tfor (var j = 0; j < datasetIndex; ++j) {\\n\\t\\t\\t\\tif (helpers.isDatasetVisible(this.chart.data.datasets[j])) {\\n\\t\\t\\t\\t\\t++ringIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ringIndex;\\n\\t\\t},\\n\\n\\t\\tupdate: function update(reset) {\\n\\t\\t\\tvar minSize = Math.min(this.chart.chartArea.right - this.chart.chartArea.left, this.chart.chartArea.bottom - this.chart.chartArea.top);\\n\\n\\t\\t\\tthis.chart.outerRadius = Math.max((minSize / 2) - this.chart.options.elements.arc.borderWidth / 2, 0);\\n\\t\\t\\tthis.chart.innerRadius = Math.max(this.chart.options.cutoutPercentage ? (this.chart.outerRadius / 100) * (this.chart.options.cutoutPercentage) : 1, 0);\\n\\t\\t\\tthis.chart.radiusLength = (this.chart.outerRadius - this.chart.innerRadius) / this.getVisibleDatasetCount();\\n\\n\\t\\t\\tthis.getDataset().total = 0;\\n\\t\\t\\thelpers.each(this.getDataset().data, function(value) {\\n\\t\\t\\t\\tif (!isNaN(value)) {\\n\\t\\t\\t\\t\\tthis.getDataset().total += Math.abs(value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this);\\n\\n\\t\\t\\tthis.outerRadius = this.chart.outerRadius - (this.chart.radiusLength * this.getRingIndex(this.index));\\n\\t\\t\\tthis.innerRadius = this.outerRadius - this.chart.radiusLength;\\n\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(arc, index) {\\n\\t\\t\\t\\tthis.updateElement(arc, index, reset);\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\t\\tupdateElement: function(arc, index, reset) {\\n\\t\\t\\tvar centerX = (this.chart.chartArea.left + this.chart.chartArea.right) / 2;\\n\\t\\t\\tvar centerY = (this.chart.chartArea.top + this.chart.chartArea.bottom) / 2;\\n\\t\\t\\tvar startAngle = Math.PI * -0.5; // non reset case handled later\\n\\t\\t\\tvar endAngle = Math.PI * -0.5; // non reset case handled later\\n\\t\\t\\tvar circumference = reset && this.chart.options.animation.animateRotate ? 0 : this.calculateCircumference(this.getDataset().data[index]);\\n\\t\\t\\tvar innerRadius = reset && this.chart.options.animation.animateScale ? 0 : this.innerRadius;\\n\\t\\t\\tvar outerRadius = reset && this.chart.options.animation.animateScale ? 0 : this.outerRadius;\\n\\n\\t\\t\\thelpers.extend(arc, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: centerX,\\n\\t\\t\\t\\t\\ty: centerY,\\n\\t\\t\\t\\t\\tstartAngle: startAngle,\\n\\t\\t\\t\\t\\tendAngle: endAngle,\\n\\t\\t\\t\\t\\tcircumference: circumference,\\n\\t\\t\\t\\t\\touterRadius: outerRadius,\\n\\t\\t\\t\\t\\tinnerRadius: innerRadius,\\n\\n\\t\\t\\t\\t\\tbackgroundColor: arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.arc.backgroundColor),\\n\\t\\t\\t\\t\\thoverBackgroundColor: arc.custom && arc.custom.hoverBackgroundColor ? arc.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().hoverBackgroundColor, index, this.chart.options.elements.arc.hoverBackgroundColor),\\n\\t\\t\\t\\t\\tborderWidth: arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.arc.borderWidth),\\n\\t\\t\\t\\t\\tborderColor: arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.arc.borderColor),\\n\\n\\t\\t\\t\\t\\tlabel: helpers.getValueAtIndexOrDefault(this.getDataset().label, index, this.chart.data.labels[index])\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Set correct angles if not resetting\\n\\t\\t\\tif (!reset) {\\n\\n\\t\\t\\t\\tif (index === 0) {\\n\\t\\t\\t\\t\\tarc._model.startAngle = Math.PI * -0.5; // use - PI / 2 instead of 3PI / 2 to make animations better. It means that we never deal with overflow during the transition function\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tarc._model.startAngle = this.getDataset().metaData[index - 1]._model.endAngle;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarc._model.endAngle = arc._model.startAngle + arc._model.circumference;\\n\\t\\t\\t}\\n\\n\\t\\t\\tarc.pivot();\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(arc, index) {\\n\\t\\t\\t\\tarc.transition(easingDecimal).draw();\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(arc) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[arc._datasetIndex];\\n\\t\\t\\tvar index = arc._index;\\n\\n\\t\\t\\tarc._model.backgroundColor = arc.custom && arc.custom.hoverBackgroundColor ? arc.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.color(arc._model.backgroundColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\tarc._model.borderColor = arc.custom && arc.custom.hoverBorderColor ? arc.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.color(arc._model.borderColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\tarc._model.borderWidth = arc.custom && arc.custom.hoverBorderWidth ? arc.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, arc._model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(arc) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[arc._datasetIndex];\\n\\t\\t\\tvar index = arc._index;\\n\\n\\t\\t\\tarc._model.backgroundColor = arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.arc.backgroundColor);\\n\\t\\t\\tarc._model.borderColor = arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.arc.borderColor);\\n\\t\\t\\tarc._model.borderWidth = arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.arc.borderWidth);\\n\\t\\t},\\n\\n\\t\\tcalculateCircumference: function(value) {\\n\\t\\t\\tif (this.getDataset().total > 0 && !isNaN(value)) {\\n\\t\\t\\t\\treturn (Math.PI * 1.999999) * (value / this.getDataset().total);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n},{}],18:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.line = {\\n\\t\\tshowLines: true,\\n\\n\\t\\thover: {\\n\\t\\t\\tmode: \\\"label\\\"\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: \\\"category\\\",\\n\\t\\t\\t\\tid: 'x-axis-0'\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: \\\"linear\\\",\\n\\t\\t\\t\\tid: 'y-axis-0'\\n\\t\\t\\t}]\\n\\t\\t}\\n\\t};\\n\\n\\n\\tChart.controllers.line = Chart.DatasetController.extend({\\n\\t\\taddElements: function() {\\n\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\n\\t\\t\\tthis.getDataset().metaDataset = this.getDataset().metaDataset || new Chart.elements.Line({\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_points: this.getDataset().metaData\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(this.getDataset().data, function(value, index) {\\n\\t\\t\\t\\tthis.getDataset().metaData[index] = this.getDataset().metaData[index] || new Chart.elements.Point({\\n\\t\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t\\t_index: index\\n\\t\\t\\t\\t});\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\t\\taddElementAndReset: function(index) {\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\t\\t\\tvar point = new Chart.elements.Point({\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Reset the point\\n\\t\\t\\tthis.updateElement(point, index, true);\\n\\n\\t\\t\\t// Add to the points array\\n\\t\\t\\tthis.getDataset().metaData.splice(index, 0, point);\\n\\n\\t\\t\\t// Make sure bezier control points are updated\\n\\t\\t\\tif (this.chart.options.showLines && this.chart.options.elements.line.tension !== 0)\\n\\t\\t\\t\\tthis.updateBezierControlPoints();\\n\\t\\t},\\n\\n\\t\\tupdate: function update(reset) {\\n\\t\\t\\tvar line = this.getDataset().metaDataset;\\n\\t\\t\\tvar points = this.getDataset().metaData;\\n\\n\\t\\t\\tvar yScale = this.getScaleForId(this.getDataset().yAxisID);\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar scaleBase;\\n\\n\\t\\t\\tif (yScale.min < 0 && yScale.max < 0) {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(yScale.max);\\n\\t\\t\\t} else if (yScale.min > 0 && yScale.max > 0) {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(yScale.min);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(0);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update Line\\n\\t\\t\\tif (this.chart.options.showLines) {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\tline._scale = yScale;\\n\\t\\t\\t\\tline._datasetIndex = this.index;\\n\\t\\t\\t\\t// Data\\n\\t\\t\\t\\tline._children = points;\\n\\t\\t\\t\\t// Model\\n\\t\\t\\t\\tline._model = {\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\ttension: line.custom && line.custom.tension ? line.custom.tension : helpers.getValueOrDefault(this.getDataset().tension, this.chart.options.elements.line.tension),\\n\\t\\t\\t\\t\\tbackgroundColor: line.custom && line.custom.backgroundColor ? line.custom.backgroundColor : (this.getDataset().backgroundColor || this.chart.options.elements.line.backgroundColor),\\n\\t\\t\\t\\t\\tborderWidth: line.custom && line.custom.borderWidth ? line.custom.borderWidth : (this.getDataset().borderWidth || this.chart.options.elements.line.borderWidth),\\n\\t\\t\\t\\t\\tborderColor: line.custom && line.custom.borderColor ? line.custom.borderColor : (this.getDataset().borderColor || this.chart.options.elements.line.borderColor),\\n\\t\\t\\t\\t\\tborderCapStyle: line.custom && line.custom.borderCapStyle ? line.custom.borderCapStyle : (this.getDataset().borderCapStyle || this.chart.options.elements.line.borderCapStyle),\\n\\t\\t\\t\\t\\tborderDash: line.custom && line.custom.borderDash ? line.custom.borderDash : (this.getDataset().borderDash || this.chart.options.elements.line.borderDash),\\n\\t\\t\\t\\t\\tborderDashOffset: line.custom && line.custom.borderDashOffset ? line.custom.borderDashOffset : (this.getDataset().borderDashOffset || this.chart.options.elements.line.borderDashOffset),\\n\\t\\t\\t\\t\\tborderJoinStyle: line.custom && line.custom.borderJoinStyle ? line.custom.borderJoinStyle : (this.getDataset().borderJoinStyle || this.chart.options.elements.line.borderJoinStyle),\\n\\t\\t\\t\\t\\tfill: line.custom && line.custom.fill ? line.custom.fill : (this.getDataset().fill !== undefined ? this.getDataset().fill : this.chart.options.elements.line.fill),\\n\\t\\t\\t\\t\\t// Scale\\n\\t\\t\\t\\t\\tscaleTop: yScale.top,\\n\\t\\t\\t\\t\\tscaleBottom: yScale.bottom,\\n\\t\\t\\t\\t\\tscaleZero: scaleBase\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tline.pivot();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update Points\\n\\t\\t\\thelpers.each(points, function(point, index) {\\n\\t\\t\\t\\tthis.updateElement(point, index, reset);\\n\\t\\t\\t}, this);\\n\\n\\t\\t\\tif (this.chart.options.showLines && this.chart.options.elements.line.tension !== 0)\\n\\t\\t\\t\\tthis.updateBezierControlPoints();\\n\\t\\t},\\n\\n\\t\\tgetPointBackgroundColor: function(point, index) {\\n\\t\\t\\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\n\\t\\t\\tif (point.custom && point.custom.backgroundColor) {\\n\\t\\t\\t\\tbackgroundColor = point.custom.backgroundColor;\\n\\t\\t\\t} else if (dataset.pointBackgroundColor) {\\n\\t\\t\\t\\tbackgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\\n\\t\\t\\t} else if (dataset.backgroundColor) {\\n\\t\\t\\t\\tbackgroundColor = dataset.backgroundColor;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn backgroundColor;\\n\\t\\t},\\n\\t\\tgetPointBorderColor: function(point, index) {\\n\\t\\t\\tvar borderColor = this.chart.options.elements.point.borderColor;\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\n\\t\\t\\tif (point.custom && point.custom.borderColor) {\\n\\t\\t\\t\\tborderColor = point.custom.borderColor;\\n\\t\\t\\t} else if (dataset.pointBorderColor) {\\n\\t\\t\\t\\tborderColor = helpers.getValueAtIndexOrDefault(this.getDataset().pointBorderColor, index, borderColor);\\n\\t\\t\\t} else if (dataset.borderColor) {\\n\\t\\t\\t\\tborderColor = dataset.borderColor;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn borderColor;\\n\\t\\t},\\n\\t\\tgetPointBorderWidth: function(point, index) {\\n\\t\\t\\tvar borderWidth = this.chart.options.elements.point.borderWidth;\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\n\\t\\t\\tif (point.custom && point.custom.borderWidth !== undefined) {\\n\\t\\t\\t\\tborderWidth = point.custom.borderWidth;\\n\\t\\t\\t} else if (dataset.pointBorderWidth !== undefined) {\\n\\t\\t\\t\\tborderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\\n\\t\\t\\t} else if (dataset.borderWidth !== undefined) {\\n\\t\\t\\t\\tborderWidth = dataset.borderWidth;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn borderWidth;\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(point, index, reset) {\\n\\t\\t\\tvar yScale = this.getScaleForId(this.getDataset().yAxisID);\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar scaleBase;\\n\\n\\t\\t\\tif (yScale.min < 0 && yScale.max < 0) {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(yScale.max);\\n\\t\\t\\t} else if (yScale.min > 0 && yScale.max > 0) {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(yScale.min);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tscaleBase = yScale.getPixelForValue(0);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Utility\\n\\t\\t\\tpoint._chart = this.chart.chart;\\n\\t\\t\\tpoint._xScale = xScale;\\n\\t\\t\\tpoint._yScale = yScale;\\n\\t\\t\\tpoint._datasetIndex = this.index;\\n\\t\\t\\tpoint._index = index;\\n\\n\\t\\t\\t// Desired view properties\\n\\t\\t\\tpoint._model = {\\n\\t\\t\\t\\tx: xScale.getPixelForValue(this.getDataset().data[index], index, this.index, this.chart.isCombo),\\n\\t\\t\\t\\ty: reset ? scaleBase : this.calculatePointY(this.getDataset().data[index], index, this.index, this.chart.isCombo),\\n\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\ttension: point.custom && point.custom.tension ? point.custom.tension : helpers.getValueOrDefault(this.getDataset().tension, this.chart.options.elements.line.tension),\\n\\t\\t\\t\\tradius: point.custom && point.custom.radius ? point.custom.radius : helpers.getValueAtIndexOrDefault(this.getDataset().radius, index, this.chart.options.elements.point.radius),\\n\\t\\t\\t\\tpointStyle: point.custom && point.custom.pointStyle ? point.custom.pointStyle : helpers.getValueAtIndexOrDefault(this.getDataset().pointStyle, index, this.chart.options.elements.point.pointStyle),\\n\\t\\t\\t\\tbackgroundColor: this.getPointBackgroundColor(point, index),\\n\\t\\t\\t\\tborderColor: this.getPointBorderColor(point, index),\\n\\t\\t\\t\\tborderWidth: this.getPointBorderWidth(point, index),\\n\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\thitRadius: point.custom && point.custom.hitRadius ? point.custom.hitRadius : helpers.getValueAtIndexOrDefault(this.getDataset().hitRadius, index, this.chart.options.elements.point.hitRadius)\\n\\t\\t\\t};\\n\\n\\t\\t\\tpoint._model.skip = point.custom && point.custom.skip ? point.custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\\n\\t\\t},\\n\\n\\t\\tcalculatePointY: function(value, index, datasetIndex, isCombo) {\\n\\n\\t\\t\\tvar xScale = this.getScaleForId(this.getDataset().xAxisID);\\n\\t\\t\\tvar yScale = this.getScaleForId(this.getDataset().yAxisID);\\n\\n\\t\\t\\tif (yScale.options.stacked) {\\n\\n\\t\\t\\t\\tvar sumPos = 0,\\n\\t\\t\\t\\t\\tsumNeg = 0;\\n\\n\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tvar ds = this.chart.data.datasets[i];\\n\\t\\t\\t\\t\\tif (ds.type === 'line' && helpers.isDatasetVisible(ds)) {\\n\\t\\t\\t\\t\\t\\tif (ds.data[index] < 0) {\\n\\t\\t\\t\\t\\t\\t\\tsumNeg += ds.data[index] || 0;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsumPos += ds.data[index] || 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (value < 0) {\\n\\t\\t\\t\\t\\treturn yScale.getPixelForValue(sumNeg + value);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn yScale.getPixelForValue(sumPos + value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn yScale.getPixelForValue(value);\\n\\t\\t},\\n\\n\\t\\tupdateBezierControlPoints: function() {\\n\\t\\t\\t// Update bezier control points\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(point, index) {\\n\\t\\t\\t\\tvar controlPoints = helpers.splineCurve(\\n\\t\\t\\t\\t\\thelpers.previousItem(this.getDataset().metaData, index)._model,\\n\\t\\t\\t\\t\\tpoint._model,\\n\\t\\t\\t\\t\\thelpers.nextItem(this.getDataset().metaData, index)._model,\\n\\t\\t\\t\\t\\tpoint._model.tension\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Prevent the bezier going outside of the bounds of the graph\\n\\t\\t\\t\\tpoint._model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, this.chart.chartArea.right), this.chart.chartArea.left);\\n\\t\\t\\t\\tpoint._model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, this.chart.chartArea.bottom), this.chart.chartArea.top);\\n\\n\\t\\t\\t\\tpoint._model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, this.chart.chartArea.right), this.chart.chartArea.left);\\n\\t\\t\\t\\tpoint._model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, this.chart.chartArea.bottom), this.chart.chartArea.top);\\n\\n\\t\\t\\t\\t// Now pivot the point for animation\\n\\t\\t\\t\\tpoint.pivot();\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\n\\t\\t\\t// Transition Point Locations\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(point) {\\n\\t\\t\\t\\tpoint.transition(easingDecimal);\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Transition and Draw the line\\n\\t\\t\\tif (this.chart.options.showLines)\\n\\t\\t\\t\\tthis.getDataset().metaDataset.transition(easingDecimal).draw();\\n\\n\\t\\t\\t// Draw the points\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(point) {\\n\\t\\t\\t\\tpoint.draw();\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(point) {\\n\\t\\t\\t// Point\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\n\\t\\t\\tpoint._model.radius = point.custom && point.custom.hoverRadius ? point.custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\\n\\t\\t\\tpoint._model.backgroundColor = point.custom && point.custom.hoverBackgroundColor ? point.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.color(point._model.backgroundColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\tpoint._model.borderColor = point.custom && point.custom.hoverBorderColor ? point.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.color(point._model.borderColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\tpoint._model.borderWidth = point.custom && point.custom.hoverBorderWidth ? point.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, point._model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(point) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\n\\t\\t\\tpoint._model.radius = point.custom && point.custom.radius ? point.custom.radius : helpers.getValueAtIndexOrDefault(this.getDataset().radius, index, this.chart.options.elements.point.radius);\\n\\t\\t\\tpoint._model.backgroundColor = this.getPointBackgroundColor(point, index);\\n\\t\\t\\tpoint._model.borderColor = this.getPointBorderColor(point, index);\\n\\t\\t\\tpoint._model.borderWidth = this.getPointBorderWidth(point, index);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],19:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.polarArea = {\\n\\n\\t\\tscale: {\\n\\t\\t\\ttype: \\\"radialLinear\\\",\\n\\t\\t\\tlineArc: true // so that lines are circular\\n\\t\\t},\\n\\n\\t\\t//Boolean - Whether to animate the rotation of the chart\\n\\t\\tanimateRotate: true,\\n\\t\\tanimateScale: true,\\n\\n\\t\\taspectRatio: 1,\\n\\t\\tlegendCallback: function(chart) {\\n\\t\\t\\tvar text = [];\\n\\t\\t\\ttext.push('<ul class=\\\"' + chart.id + '-legend\\\">');\\n\\n\\t\\t\\tif (chart.data.datasets.length) {\\n\\t\\t\\t\\tfor (var i = 0; i < chart.data.datasets[0].data.length; ++i) {\\n\\t\\t\\t\\t\\ttext.push('<li><span style=\\\"background-color:' + chart.data.datasets[0].backgroundColor[i] + '\\\">');\\n\\t\\t\\t\\t\\tif (chart.data.labels[i]) {\\n\\t\\t\\t\\t\\t\\ttext.push(chart.data.labels[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttext.push('</span></li>');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\ttext.push('</ul>');\\n\\t\\t\\treturn text.join(\\\"\\\");\\n\\t\\t},\\n\\t\\tlegend: {\\n\\t\\t\\tlabels: {\\n\\t\\t\\t\\tgenerateLabels: function(data) {\\n\\t\\t\\t\\t\\tif (data.labels.length && data.datasets.length) {\\n\\t\\t\\t\\t\\t\\treturn data.labels.map(function(label, i) {\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\ttext: label,\\n\\t\\t\\t\\t\\t\\t\\t\\tfillStyle: data.datasets[0].backgroundColor[i],\\n\\t\\t\\t\\t\\t\\t\\t\\thidden: isNaN(data.datasets[0].data[i]),\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Extra data used for toggling the correct item\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn [];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tonClick: function(e, legendItem) {\\n\\t\\t\\t\\thelpers.each(this.chart.data.datasets, function(dataset) {\\n\\t\\t\\t\\t\\tdataset.metaHiddenData = dataset.metaHiddenData || [];\\n\\t\\t\\t\\t\\tvar idx = legendItem.index;\\n\\n\\t\\t\\t\\t\\tif (!isNaN(dataset.data[idx])) {\\n\\t\\t\\t\\t\\t\\tdataset.metaHiddenData[idx] = dataset.data[idx];\\n\\t\\t\\t\\t\\t\\tdataset.data[idx] = NaN;\\n\\t\\t\\t\\t\\t} else if (!isNaN(dataset.metaHiddenData[idx])) {\\n\\t\\t\\t\\t\\t\\tdataset.data[idx] = dataset.metaHiddenData[idx];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tthis.chart.update();\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Need to override these to give a nice default\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function() {\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\treturn data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.polarArea = Chart.DatasetController.extend({\\n\\t\\tlinkScales: function() {\\n\\t\\t\\t// no scales for doughnut\\n\\t\\t},\\n\\t\\taddElements: function() {\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\t\\t\\thelpers.each(this.getDataset().data, function(value, index) {\\n\\t\\t\\t\\tthis.getDataset().metaData[index] = this.getDataset().metaData[index] || new Chart.elements.Arc({\\n\\t\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t\\t_index: index\\n\\t\\t\\t\\t});\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\t\\taddElementAndReset: function(index) {\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\t\\t\\tvar arc = new Chart.elements.Arc({\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Reset the point\\n\\t\\t\\tthis.updateElement(arc, index, true);\\n\\n\\t\\t\\t// Add to the points array\\n\\t\\t\\tthis.getDataset().metaData.splice(index, 0, arc);\\n\\t\\t},\\n\\t\\tgetVisibleDatasetCount: function getVisibleDatasetCount() {\\n\\t\\t\\treturn helpers.where(this.chart.data.datasets, function(ds) {\\n\\t\\t\\t\\treturn helpers.isDatasetVisible(ds);\\n\\t\\t\\t}).length;\\n\\t\\t},\\n\\n\\t\\tupdate: function update(reset) {\\n\\t\\t\\tvar minSize = Math.min(this.chart.chartArea.right - this.chart.chartArea.left, this.chart.chartArea.bottom - this.chart.chartArea.top);\\n\\t\\t\\tthis.chart.outerRadius = Math.max((minSize - this.chart.options.elements.arc.borderWidth / 2) / 2, 0);\\n\\t\\t\\tthis.chart.innerRadius = Math.max(this.chart.options.cutoutPercentage ? (this.chart.outerRadius / 100) * (this.chart.options.cutoutPercentage) : 1, 0);\\n\\t\\t\\tthis.chart.radiusLength = (this.chart.outerRadius - this.chart.innerRadius) / this.getVisibleDatasetCount();\\n\\n\\t\\t\\tthis.getDataset().total = 0;\\n\\t\\t\\thelpers.each(this.getDataset().data, function(value) {\\n\\t\\t\\t\\tthis.getDataset().total += Math.abs(value);\\n\\t\\t\\t}, this);\\n\\n\\t\\t\\tthis.outerRadius = this.chart.outerRadius - (this.chart.radiusLength * this.index);\\n\\t\\t\\tthis.innerRadius = this.outerRadius - this.chart.radiusLength;\\n\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(arc, index) {\\n\\t\\t\\t\\tthis.updateElement(arc, index, reset);\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(arc, index, reset) {\\n\\t\\t\\tvar circumference = this.calculateCircumference(this.getDataset().data[index]);\\n\\t\\t\\tvar centerX = (this.chart.chartArea.left + this.chart.chartArea.right) / 2;\\n\\t\\t\\tvar centerY = (this.chart.chartArea.top + this.chart.chartArea.bottom) / 2;\\n\\n\\t\\t\\t// If there is NaN data before us, we need to calculate the starting angle correctly.\\n\\t\\t\\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\\n\\t\\t\\tvar notNullIndex = 0;\\n\\t\\t\\tfor (var i = 0; i < index; ++i) {\\n\\t\\t\\t\\tif (!isNaN(this.getDataset().data[i])) {\\n\\t\\t\\t\\t\\t++notNullIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar startAngle = (-0.5 * Math.PI) + (circumference * notNullIndex);\\n\\t\\t\\tvar endAngle = startAngle + circumference;\\n\\n\\t\\t\\tvar resetModel = {\\n\\t\\t\\t\\tx: centerX,\\n\\t\\t\\t\\ty: centerY,\\n\\t\\t\\t\\tinnerRadius: 0,\\n\\t\\t\\t\\touterRadius: this.chart.options.animateScale ? 0 : this.chart.scale.getDistanceFromCenterForValue(this.getDataset().data[index]),\\n\\t\\t\\t\\tstartAngle: this.chart.options.animateRotate ? Math.PI * -0.5 : startAngle,\\n\\t\\t\\t\\tendAngle: this.chart.options.animateRotate ? Math.PI * -0.5 : endAngle,\\n\\n\\t\\t\\t\\tbackgroundColor: arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.arc.backgroundColor),\\n\\t\\t\\t\\tborderWidth: arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.arc.borderWidth),\\n\\t\\t\\t\\tborderColor: arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.arc.borderColor),\\n\\n\\t\\t\\t\\tlabel: helpers.getValueAtIndexOrDefault(this.chart.data.labels, index, this.chart.data.labels[index])\\n\\t\\t\\t};\\n\\n\\t\\t\\thelpers.extend(arc, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index,\\n\\t\\t\\t\\t_scale: this.chart.scale,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: reset ? resetModel : {\\n\\t\\t\\t\\t\\tx: centerX,\\n\\t\\t\\t\\t\\ty: centerY,\\n\\t\\t\\t\\t\\tinnerRadius: 0,\\n\\t\\t\\t\\t\\touterRadius: this.chart.scale.getDistanceFromCenterForValue(this.getDataset().data[index]),\\n\\t\\t\\t\\t\\tstartAngle: startAngle,\\n\\t\\t\\t\\t\\tendAngle: endAngle,\\n\\n\\t\\t\\t\\t\\tbackgroundColor: arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.arc.backgroundColor),\\n\\t\\t\\t\\t\\tborderWidth: arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.arc.borderWidth),\\n\\t\\t\\t\\t\\tborderColor: arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.arc.borderColor),\\n\\n\\t\\t\\t\\t\\tlabel: helpers.getValueAtIndexOrDefault(this.chart.data.labels, index, this.chart.data.labels[index])\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tarc.pivot();\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(arc, index) {\\n\\t\\t\\t\\tarc.transition(easingDecimal).draw();\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(arc) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[arc._datasetIndex];\\n\\t\\t\\tvar index = arc._index;\\n\\n\\t\\t\\tarc._model.backgroundColor = arc.custom && arc.custom.hoverBackgroundColor ? arc.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.color(arc._model.backgroundColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\tarc._model.borderColor = arc.custom && arc.custom.hoverBorderColor ? arc.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.color(arc._model.borderColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\tarc._model.borderWidth = arc.custom && arc.custom.hoverBorderWidth ? arc.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, arc._model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(arc) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[arc._datasetIndex];\\n\\t\\t\\tvar index = arc._index;\\n\\n\\t\\t\\tarc._model.backgroundColor = arc.custom && arc.custom.backgroundColor ? arc.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().backgroundColor, index, this.chart.options.elements.arc.backgroundColor);\\n\\t\\t\\tarc._model.borderColor = arc.custom && arc.custom.borderColor ? arc.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().borderColor, index, this.chart.options.elements.arc.borderColor);\\n\\t\\t\\tarc._model.borderWidth = arc.custom && arc.custom.borderWidth ? arc.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().borderWidth, index, this.chart.options.elements.arc.borderWidth);\\n\\t\\t},\\n\\n\\t\\tcalculateCircumference: function(value) {\\n\\t\\t\\tif (isNaN(value)) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Count the number of NaN values\\n\\t\\t\\t\\tvar numNaN = helpers.where(this.getDataset().data, function(data) {\\n\\t\\t\\t\\t\\treturn isNaN(data);\\n\\t\\t\\t\\t}).length;\\n\\n\\t\\t\\t\\treturn (2 * Math.PI) / (this.getDataset().data.length - numNaN);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n\\n};\\n},{}],20:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\n\\tChart.defaults.radar = {\\n\\t\\tscale: {\\n\\t\\t\\ttype: \\\"radialLinear\\\"\\n\\t\\t},\\n\\t\\telements: {\\n\\t\\t\\tline: {\\n\\t\\t\\t\\ttension: 0 // no bezier in radar\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.radar = Chart.DatasetController.extend({\\n\\t\\tlinkScales: function() {\\n\\t\\t\\t// No need. Single scale only\\n\\t\\t},\\n\\n\\t\\taddElements: function() {\\n\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\n\\t\\t\\tthis.getDataset().metaDataset = this.getDataset().metaDataset || new Chart.elements.Line({\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_points: this.getDataset().metaData,\\n\\t\\t\\t\\t_loop: true\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(this.getDataset().data, function(value, index) {\\n\\t\\t\\t\\tthis.getDataset().metaData[index] = this.getDataset().metaData[index] || new Chart.elements.Point({\\n\\t\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t\\t_index: index,\\n\\t\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\t\\tx: 0, //xScale.getPixelForValue(null, index, true),\\n\\t\\t\\t\\t\\t\\ty: 0 //this.chartArea.bottom,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\t\\taddElementAndReset: function(index) {\\n\\t\\t\\tthis.getDataset().metaData = this.getDataset().metaData || [];\\n\\t\\t\\tvar point = new Chart.elements.Point({\\n\\t\\t\\t\\t_chart: this.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Reset the point\\n\\t\\t\\tthis.updateElement(point, index, true);\\n\\n\\t\\t\\t// Add to the points array\\n\\t\\t\\tthis.getDataset().metaData.splice(index, 0, point);\\n\\n\\t\\t\\t// Make sure bezier control points are updated\\n\\t\\t\\tthis.updateBezierControlPoints();\\n\\t\\t},\\n\\n\\t\\tupdate: function update(reset) {\\n\\n\\t\\t\\tvar line = this.getDataset().metaDataset;\\n\\t\\t\\tvar points = this.getDataset().metaData;\\n\\n\\t\\t\\tvar scale = this.chart.scale;\\n\\t\\t\\tvar scaleBase;\\n\\n\\t\\t\\tif (scale.min < 0 && scale.max < 0) {\\n\\t\\t\\t\\tscaleBase = scale.getPointPositionForValue(0, scale.max);\\n\\t\\t\\t} else if (scale.min > 0 && scale.max > 0) {\\n\\t\\t\\t\\tscaleBase = scale.getPointPositionForValue(0, scale.min);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tscaleBase = scale.getPointPositionForValue(0, 0);\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.extend(this.getDataset().metaDataset, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t// Data\\n\\t\\t\\t\\t_children: this.getDataset().metaData,\\n\\t\\t\\t\\t// Model\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\ttension: line.custom && line.custom.tension ? line.custom.tension : helpers.getValueOrDefault(this.getDataset().tension, this.chart.options.elements.line.tension),\\n\\t\\t\\t\\t\\tbackgroundColor: line.custom && line.custom.backgroundColor ? line.custom.backgroundColor : (this.getDataset().backgroundColor || this.chart.options.elements.line.backgroundColor),\\n\\t\\t\\t\\t\\tborderWidth: line.custom && line.custom.borderWidth ? line.custom.borderWidth : (this.getDataset().borderWidth || this.chart.options.elements.line.borderWidth),\\n\\t\\t\\t\\t\\tborderColor: line.custom && line.custom.borderColor ? line.custom.borderColor : (this.getDataset().borderColor || this.chart.options.elements.line.borderColor),\\n\\t\\t\\t\\t\\tfill: line.custom && line.custom.fill ? line.custom.fill : (this.getDataset().fill !== undefined ? this.getDataset().fill : this.chart.options.elements.line.fill),\\n\\t\\t\\t\\t\\tborderCapStyle: line.custom && line.custom.borderCapStyle ? line.custom.borderCapStyle : (this.getDataset().borderCapStyle || this.chart.options.elements.line.borderCapStyle),\\n\\t\\t\\t\\t\\tborderDash: line.custom && line.custom.borderDash ? line.custom.borderDash : (this.getDataset().borderDash || this.chart.options.elements.line.borderDash),\\n\\t\\t\\t\\t\\tborderDashOffset: line.custom && line.custom.borderDashOffset ? line.custom.borderDashOffset : (this.getDataset().borderDashOffset || this.chart.options.elements.line.borderDashOffset),\\n\\t\\t\\t\\t\\tborderJoinStyle: line.custom && line.custom.borderJoinStyle ? line.custom.borderJoinStyle : (this.getDataset().borderJoinStyle || this.chart.options.elements.line.borderJoinStyle),\\n\\n\\t\\t\\t\\t\\t// Scale\\n\\t\\t\\t\\t\\tscaleTop: scale.top,\\n\\t\\t\\t\\t\\tscaleBottom: scale.bottom,\\n\\t\\t\\t\\t\\tscaleZero: scaleBase\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis.getDataset().metaDataset.pivot();\\n\\n\\t\\t\\t// Update Points\\n\\t\\t\\thelpers.each(points, function(point, index) {\\n\\t\\t\\t\\tthis.updateElement(point, index, reset);\\n\\t\\t\\t}, this);\\n\\n\\n\\t\\t\\t// Update bezier control points\\n\\t\\t\\tthis.updateBezierControlPoints();\\n\\t\\t},\\n\\t\\tupdateElement: function(point, index, reset) {\\n\\t\\t\\tvar pointPosition = this.chart.scale.getPointPositionForValue(index, this.getDataset().data[index]);\\n\\n\\t\\t\\thelpers.extend(point, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_datasetIndex: this.index,\\n\\t\\t\\t\\t_index: index,\\n\\t\\t\\t\\t_scale: this.chart.scale,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: reset ? this.chart.scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\\n\\t\\t\\t\\t\\ty: reset ? this.chart.scale.yCenter : pointPosition.y,\\n\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\ttension: point.custom && point.custom.tension ? point.custom.tension : helpers.getValueOrDefault(this.getDataset().tension, this.chart.options.elements.line.tension),\\n\\t\\t\\t\\t\\tradius: point.custom && point.custom.radius ? point.custom.radius : helpers.getValueAtIndexOrDefault(this.getDataset().pointRadius, index, this.chart.options.elements.point.radius),\\n\\t\\t\\t\\t\\tbackgroundColor: point.custom && point.custom.backgroundColor ? point.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().pointBackgroundColor, index, this.chart.options.elements.point.backgroundColor),\\n\\t\\t\\t\\t\\tborderColor: point.custom && point.custom.borderColor ? point.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().pointBorderColor, index, this.chart.options.elements.point.borderColor),\\n\\t\\t\\t\\t\\tborderWidth: point.custom && point.custom.borderWidth ? point.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().pointBorderWidth, index, this.chart.options.elements.point.borderWidth),\\n\\t\\t\\t\\t\\tpointStyle: point.custom && point.custom.pointStyle ? point.custom.pointStyle : helpers.getValueAtIndexOrDefault(this.getDataset().pointStyle, index, this.chart.options.elements.point.pointStyle),\\n\\n\\t\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\t\\thitRadius: point.custom && point.custom.hitRadius ? point.custom.hitRadius : helpers.getValueAtIndexOrDefault(this.getDataset().hitRadius, index, this.chart.options.elements.point.hitRadius)\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tpoint._model.skip = point.custom && point.custom.skip ? point.custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\\n\\t\\t},\\n\\t\\tupdateBezierControlPoints: function() {\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(point, index) {\\n\\t\\t\\t\\tvar controlPoints = helpers.splineCurve(\\n\\t\\t\\t\\t\\thelpers.previousItem(this.getDataset().metaData, index, true)._model,\\n\\t\\t\\t\\t\\tpoint._model,\\n\\t\\t\\t\\t\\thelpers.nextItem(this.getDataset().metaData, index, true)._model,\\n\\t\\t\\t\\t\\tpoint._model.tension\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Prevent the bezier going outside of the bounds of the graph\\n\\t\\t\\t\\tpoint._model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, this.chart.chartArea.right), this.chart.chartArea.left);\\n\\t\\t\\t\\tpoint._model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, this.chart.chartArea.bottom), this.chart.chartArea.top);\\n\\n\\t\\t\\t\\tpoint._model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, this.chart.chartArea.right), this.chart.chartArea.left);\\n\\t\\t\\t\\tpoint._model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, this.chart.chartArea.bottom), this.chart.chartArea.top);\\n\\n\\t\\t\\t\\t// Now pivot the point for animation\\n\\t\\t\\t\\tpoint.pivot();\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\n\\t\\t\\t// Transition Point Locations\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(point, index) {\\n\\t\\t\\t\\tpoint.transition(easingDecimal);\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Transition and Draw the line\\n\\t\\t\\tthis.getDataset().metaDataset.transition(easingDecimal).draw();\\n\\n\\t\\t\\t// Draw the points\\n\\t\\t\\thelpers.each(this.getDataset().metaData, function(point) {\\n\\t\\t\\t\\tpoint.draw();\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(point) {\\n\\t\\t\\t// Point\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\n\\t\\t\\tpoint._model.radius = point.custom && point.custom.hoverRadius ? point.custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\\n\\t\\t\\tpoint._model.backgroundColor = point.custom && point.custom.hoverBackgroundColor ? point.custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.color(point._model.backgroundColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\tpoint._model.borderColor = point.custom && point.custom.hoverBorderColor ? point.custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.color(point._model.borderColor).saturate(0.5).darken(0.1).rgbString());\\n\\t\\t\\tpoint._model.borderWidth = point.custom && point.custom.hoverBorderWidth ? point.custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, point._model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(point) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\n\\t\\t\\tpoint._model.radius = point.custom && point.custom.radius ? point.custom.radius : helpers.getValueAtIndexOrDefault(this.getDataset().radius, index, this.chart.options.elements.point.radius);\\n\\t\\t\\tpoint._model.backgroundColor = point.custom && point.custom.backgroundColor ? point.custom.backgroundColor : helpers.getValueAtIndexOrDefault(this.getDataset().pointBackgroundColor, index, this.chart.options.elements.point.backgroundColor);\\n\\t\\t\\tpoint._model.borderColor = point.custom && point.custom.borderColor ? point.custom.borderColor : helpers.getValueAtIndexOrDefault(this.getDataset().pointBorderColor, index, this.chart.options.elements.point.borderColor);\\n\\t\\t\\tpoint._model.borderWidth = point.custom && point.custom.borderWidth ? point.custom.borderWidth : helpers.getValueAtIndexOrDefault(this.getDataset().pointBorderWidth, index, this.chart.options.elements.point.borderWidth);\\n\\t\\t}\\n\\t});\\n};\\n},{}],21:[function(require,module,exports){\\n/*global window: false */\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.global.animation = {\\n\\t\\tduration: 1000,\\n\\t\\teasing: \\\"easeOutQuart\\\",\\n\\t\\tonProgress: helpers.noop,\\n\\t\\tonComplete: helpers.noop\\n\\t};\\n\\n\\tChart.Animation = Chart.Element.extend({\\n\\t\\tcurrentStep: null, // the current animation step\\n\\t\\tnumSteps: 60, // default number of steps\\n\\t\\teasing: \\\"\\\", // the easing to use for this animation\\n\\t\\trender: null, // render function used by the animation service\\n\\n\\t\\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\\n\\t\\tonAnimationComplete: null // user specified callback to fire when the animation finishes\\n\\t});\\n\\n\\tChart.animationService = {\\n\\t\\tframeDuration: 17,\\n\\t\\tanimations: [],\\n\\t\\tdropFrames: 0,\\n\\t\\taddAnimation: function(chartInstance, animationObject, duration, lazy) {\\n\\n\\t\\t\\tif (!lazy) {\\n\\t\\t\\t\\tchartInstance.animating = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (var index = 0; index < this.animations.length; ++index) {\\n\\t\\t\\t\\tif (this.animations[index].chartInstance === chartInstance) {\\n\\t\\t\\t\\t\\t// replacing an in progress animation\\n\\t\\t\\t\\t\\tthis.animations[index].animationObject = animationObject;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.animations.push({\\n\\t\\t\\t\\tchartInstance: chartInstance,\\n\\t\\t\\t\\tanimationObject: animationObject\\n\\t\\t\\t});\\n\\n\\t\\t\\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\\n\\t\\t\\tif (this.animations.length === 1) {\\n\\t\\t\\t\\thelpers.requestAnimFrame.call(window, this.digestWrapper);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\t// Cancel the animation for a given chart instance\\n\\t\\tcancelAnimation: function(chartInstance) {\\n\\t\\t\\tvar index = helpers.findIndex(this.animations, function(animationWrapper) {\\n\\t\\t\\t\\treturn animationWrapper.chartInstance === chartInstance;\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (index !== -1) {\\n\\t\\t\\t\\tthis.animations.splice(index, 1);\\n\\t\\t\\t\\tchartInstance.animating = false;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\t// calls startDigest with the proper context\\n\\t\\tdigestWrapper: function() {\\n\\t\\t\\tChart.animationService.startDigest.call(Chart.animationService);\\n\\t\\t},\\n\\t\\tstartDigest: function() {\\n\\n\\t\\t\\tvar startTime = Date.now();\\n\\t\\t\\tvar framesToDrop = 0;\\n\\n\\t\\t\\tif (this.dropFrames > 1) {\\n\\t\\t\\t\\tframesToDrop = Math.floor(this.dropFrames);\\n\\t\\t\\t\\tthis.dropFrames = this.dropFrames % 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\twhile (i < this.animations.length) {\\n\\t\\t\\t\\tif (this.animations[i].animationObject.currentStep === null) {\\n\\t\\t\\t\\t\\tthis.animations[i].animationObject.currentStep = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.animations[i].animationObject.currentStep += 1 + framesToDrop;\\n\\n\\t\\t\\t\\tif (this.animations[i].animationObject.currentStep > this.animations[i].animationObject.numSteps) {\\n\\t\\t\\t\\t\\tthis.animations[i].animationObject.currentStep = this.animations[i].animationObject.numSteps;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.animations[i].animationObject.render(this.animations[i].chartInstance, this.animations[i].animationObject);\\n\\t\\t\\t\\tif (this.animations[i].animationObject.onAnimationProgress && this.animations[i].animationObject.onAnimationProgress.call) {\\n\\t\\t\\t\\t\\tthis.animations[i].animationObject.onAnimationProgress.call(this.animations[i].chartInstance, this.animations[i]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (this.animations[i].animationObject.currentStep === this.animations[i].animationObject.numSteps) {\\n\\t\\t\\t\\t\\tif (this.animations[i].animationObject.onAnimationComplete && this.animations[i].animationObject.onAnimationComplete.call) {\\n\\t\\t\\t\\t\\t\\tthis.animations[i].animationObject.onAnimationComplete.call(this.animations[i].chartInstance, this.animations[i]);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// executed the last frame. Remove the animation.\\n\\t\\t\\t\\t\\tthis.animations[i].chartInstance.animating = false;\\n\\n\\t\\t\\t\\t\\tthis.animations.splice(i, 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar endTime = Date.now();\\n\\t\\t\\tvar dropFrames = (endTime - startTime) / this.frameDuration;\\n\\n\\t\\t\\tthis.dropFrames += dropFrames;\\n\\n\\t\\t\\t// Do we have more stuff to animate?\\n\\t\\t\\tif (this.animations.length > 0) {\\n\\t\\t\\t\\thelpers.requestAnimFrame.call(window, this.digestWrapper);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n},{}],22:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\t//Create a dictionary of chart types, to allow for extension of existing types\\n\\tChart.types = {};\\n\\n\\t//Store a reference to each instance - allowing us to globally resize chart instances on window resize.\\n\\t//Destroy method on the chart will remove the instance of the chart from this reference.\\n\\tChart.instances = {};\\n\\n\\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\\n\\tChart.controllers = {};\\n\\n\\t// The main controller of a chart\\n\\tChart.Controller = function(instance) {\\n\\n\\t\\tthis.chart = instance;\\n\\t\\tthis.config = instance.config;\\n\\t\\tthis.options = this.config.options = helpers.configMerge(Chart.defaults.global, Chart.defaults[this.config.type], this.config.options || {});\\n\\t\\tthis.id = helpers.uid();\\n\\n\\t\\tObject.defineProperty(this, 'data', {\\n\\t\\t\\tget: function() {\\n\\t\\t\\t\\treturn this.config.data;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t//Add the chart instance to the global namespace\\n\\t\\tChart.instances[this.id] = this;\\n\\n\\t\\tif (this.options.responsive) {\\n\\t\\t\\t// Silent resize before chart draws\\n\\t\\t\\tthis.resize(true);\\n\\t\\t}\\n\\n\\t\\tthis.initialize();\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\thelpers.extend(Chart.Controller.prototype, {\\n\\n\\t\\tinitialize: function initialize() {\\n\\n\\t\\t\\t// TODO\\n\\t\\t\\t// If BeforeInit(this) doesn't return false, proceed\\n\\n\\t\\t\\tthis.bindEvents();\\n\\n\\t\\t\\t// Make sure controllers are built first so that each dataset is bound to an axis before the scales\\n\\t\\t\\t// are built\\n\\t\\t\\tthis.ensureScalesHaveIDs();\\n\\t\\t\\tthis.buildOrUpdateControllers();\\n\\t\\t\\tthis.buildScales();\\n\\t\\t\\tthis.buildSurroundingItems();\\n\\t\\t\\tthis.updateLayout();\\n\\t\\t\\tthis.resetElements();\\n\\t\\t\\tthis.initToolTip();\\n\\t\\t\\tthis.update();\\n\\n\\t\\t\\t// TODO\\n\\t\\t\\t// If AfterInit(this) doesn't return false, proceed\\n\\n\\t\\t\\treturn this;\\n\\t\\t},\\n\\n\\t\\tclear: function clear() {\\n\\t\\t\\thelpers.clear(this.chart);\\n\\t\\t\\treturn this;\\n\\t\\t},\\n\\n\\t\\tstop: function stop() {\\n\\t\\t\\t// Stops any current animation loop occuring\\n\\t\\t\\tChart.animationService.cancelAnimation(this);\\n\\t\\t\\treturn this;\\n\\t\\t},\\n\\n\\t\\tresize: function resize(silent) {\\n\\t\\t\\tvar canvas = this.chart.canvas;\\n\\t\\t\\tvar newWidth = helpers.getMaximumWidth(this.chart.canvas);\\n\\t\\t\\tvar newHeight = (this.options.maintainAspectRatio && isNaN(this.chart.aspectRatio) === false && isFinite(this.chart.aspectRatio) && this.chart.aspectRatio !== 0) ? newWidth / this.chart.aspectRatio : helpers.getMaximumHeight(this.chart.canvas);\\n\\n\\t\\t\\tvar sizeChanged = this.chart.width !== newWidth || this.chart.height !== newHeight;\\n\\n\\t\\t\\tif (!sizeChanged)\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\tcanvas.width = this.chart.width = newWidth;\\n\\t\\t\\tcanvas.height = this.chart.height = newHeight;\\n\\n\\t\\t\\thelpers.retinaScale(this.chart);\\n\\n\\t\\t\\tif (!silent) {\\n\\t\\t\\t\\tthis.stop();\\n\\t\\t\\t\\tthis.update(this.options.responsiveAnimationDuration);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\t\\t},\\n\\t\\tensureScalesHaveIDs: function ensureScalesHaveIDs() {\\n\\t\\t\\tvar defaultXAxisID = 'x-axis-';\\n\\t\\t\\tvar defaultYAxisID = 'y-axis-';\\n\\n\\t\\t\\tif (this.options.scales) {\\n\\t\\t\\t\\tif (this.options.scales.xAxes && this.options.scales.xAxes.length) {\\n\\t\\t\\t\\t\\thelpers.each(this.options.scales.xAxes, function(xAxisOptions, index) {\\n\\t\\t\\t\\t\\t\\txAxisOptions.id = xAxisOptions.id || (defaultXAxisID + index);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (this.options.scales.yAxes && this.options.scales.yAxes.length) {\\n\\t\\t\\t\\t\\t// Build the y axes\\n\\t\\t\\t\\t\\thelpers.each(this.options.scales.yAxes, function(yAxisOptions, index) {\\n\\t\\t\\t\\t\\t\\tyAxisOptions.id = yAxisOptions.id || (defaultYAxisID + index);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tbuildScales: function buildScales() {\\n\\t\\t\\t// Map of scale ID to scale object so we can lookup later\\n\\t\\t\\tthis.scales = {};\\n\\n\\t\\t\\t// Build the x axes\\n\\t\\t\\tif (this.options.scales) {\\n\\t\\t\\t\\tif (this.options.scales.xAxes && this.options.scales.xAxes.length) {\\n\\t\\t\\t\\t\\thelpers.each(this.options.scales.xAxes, function(xAxisOptions, index) {\\n\\t\\t\\t\\t\\t\\tvar xType = helpers.getValueOrDefault(xAxisOptions.type, 'category');\\n\\t\\t\\t\\t\\t\\tvar ScaleClass = Chart.scaleService.getScaleConstructor(xType);\\n\\t\\t\\t\\t\\t\\tif (ScaleClass) {\\n\\t\\t\\t\\t\\t\\t\\tvar scale = new ScaleClass({\\n\\t\\t\\t\\t\\t\\t\\t\\tctx: this.chart.ctx,\\n\\t\\t\\t\\t\\t\\t\\t\\toptions: xAxisOptions,\\n\\t\\t\\t\\t\\t\\t\\t\\tchart: this,\\n\\t\\t\\t\\t\\t\\t\\t\\tid: xAxisOptions.id\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.scales[scale.id] = scale;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}, this);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (this.options.scales.yAxes && this.options.scales.yAxes.length) {\\n\\t\\t\\t\\t\\t// Build the y axes\\n\\t\\t\\t\\t\\thelpers.each(this.options.scales.yAxes, function(yAxisOptions, index) {\\n\\t\\t\\t\\t\\t\\tvar yType = helpers.getValueOrDefault(yAxisOptions.type, 'linear');\\n\\t\\t\\t\\t\\t\\tvar ScaleClass = Chart.scaleService.getScaleConstructor(yType);\\n\\t\\t\\t\\t\\t\\tif (ScaleClass) {\\n\\t\\t\\t\\t\\t\\t\\tvar scale = new ScaleClass({\\n\\t\\t\\t\\t\\t\\t\\t\\tctx: this.chart.ctx,\\n\\t\\t\\t\\t\\t\\t\\t\\toptions: yAxisOptions,\\n\\t\\t\\t\\t\\t\\t\\t\\tchart: this,\\n\\t\\t\\t\\t\\t\\t\\t\\tid: yAxisOptions.id\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.scales[scale.id] = scale;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}, this);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (this.options.scale) {\\n\\t\\t\\t\\t// Build radial axes\\n\\t\\t\\t\\tvar ScaleClass = Chart.scaleService.getScaleConstructor(this.options.scale.type);\\n\\t\\t\\t\\tif (ScaleClass) {\\n\\t\\t\\t\\t\\tvar scale = new ScaleClass({\\n\\t\\t\\t\\t\\t\\tctx: this.chart.ctx,\\n\\t\\t\\t\\t\\t\\toptions: this.options.scale,\\n\\t\\t\\t\\t\\t\\tchart: this\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\tthis.scale = scale;\\n\\n\\t\\t\\t\\t\\tthis.scales.radialScale = scale;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tChart.scaleService.addScalesToLayout(this);\\n\\t\\t},\\n\\n\\t\\tbuildSurroundingItems: function() {\\n\\t\\t\\tif (this.options.title) {\\n\\t\\t\\t\\tthis.titleBlock = new Chart.Title({\\n\\t\\t\\t\\t\\tctx: this.chart.ctx,\\n\\t\\t\\t\\t\\toptions: this.options.title,\\n\\t\\t\\t\\t\\tchart: this\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tChart.layoutService.addBox(this, this.titleBlock);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (this.options.legend) {\\n\\t\\t\\t\\tthis.legend = new Chart.Legend({\\n\\t\\t\\t\\t\\tctx: this.chart.ctx,\\n\\t\\t\\t\\t\\toptions: this.options.legend,\\n\\t\\t\\t\\t\\tchart: this\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tChart.layoutService.addBox(this, this.legend);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tupdateLayout: function() {\\n\\t\\t\\tChart.layoutService.update(this, this.chart.width, this.chart.height);\\n\\t\\t},\\n\\n\\t\\tbuildOrUpdateControllers: function buildOrUpdateControllers() {\\n\\t\\t\\tvar types = [];\\n\\t\\t\\tvar newControllers = [];\\n\\n\\t\\t\\thelpers.each(this.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tif (!dataset.type) {\\n\\t\\t\\t\\t\\tdataset.type = this.config.type;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar type = dataset.type;\\n\\t\\t\\t\\ttypes.push(type);\\n\\n\\t\\t\\t\\tif (dataset.controller) {\\n\\t\\t\\t\\t\\tdataset.controller.updateIndex(datasetIndex);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdataset.controller = new Chart.controllers[type](this, datasetIndex);\\n\\t\\t\\t\\t\\tnewControllers.push(dataset.controller);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this);\\n\\n\\t\\t\\tif (types.length > 1) {\\n\\t\\t\\t\\tfor (var i = 1; i < types.length; i++) {\\n\\t\\t\\t\\t\\tif (types[i] !== types[i - 1]) {\\n\\t\\t\\t\\t\\t\\tthis.isCombo = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn newControllers;\\n\\t\\t},\\n\\n\\t\\tresetElements: function resetElements() {\\n\\t\\t\\thelpers.each(this.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tdataset.controller.reset();\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tupdate: function update(animationDuration, lazy) {\\n\\t\\t\\t// In case the entire data object changed\\n\\t\\t\\tthis.tooltip._data = this.data;\\n\\n\\t\\t\\t// Make sure dataset controllers are updated and new controllers are reset\\n\\t\\t\\tvar newControllers = this.buildOrUpdateControllers();\\n\\n\\t\\t\\tChart.layoutService.update(this, this.chart.width, this.chart.height);\\n\\n\\t\\t\\t// Can only reset the new controllers after the scales have been updated\\n\\t\\t\\thelpers.each(newControllers, function(controller) {\\n\\t\\t\\t\\tcontroller.reset();\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Make sure all dataset controllers have correct meta data counts\\n\\t\\t\\thelpers.each(this.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tdataset.controller.buildOrUpdateElements();\\n\\t\\t\\t});\\n\\n\\t\\t\\t// This will loop through any data and do the appropriate element update for the type\\n\\t\\t\\thelpers.each(this.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tdataset.controller.update();\\n\\t\\t\\t});\\n\\t\\t\\tthis.render(animationDuration, lazy);\\n\\t\\t},\\n\\n\\t\\trender: function render(duration, lazy) {\\n\\n\\t\\t\\tif (this.options.animation && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && this.options.animation.duration !== 0))) {\\n\\t\\t\\t\\tvar animation = new Chart.Animation();\\n\\t\\t\\t\\tanimation.numSteps = (duration || this.options.animation.duration) / 16.66; //60 fps\\n\\t\\t\\t\\tanimation.easing = this.options.animation.easing;\\n\\n\\t\\t\\t\\t// render function\\n\\t\\t\\t\\tanimation.render = function(chartInstance, animationObject) {\\n\\t\\t\\t\\t\\tvar easingFunction = helpers.easingEffects[animationObject.easing];\\n\\t\\t\\t\\t\\tvar stepDecimal = animationObject.currentStep / animationObject.numSteps;\\n\\t\\t\\t\\t\\tvar easeDecimal = easingFunction(stepDecimal);\\n\\n\\t\\t\\t\\t\\tchartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// user events\\n\\t\\t\\t\\tanimation.onAnimationProgress = this.options.animation.onProgress;\\n\\t\\t\\t\\tanimation.onAnimationComplete = this.options.animation.onComplete;\\n\\n\\t\\t\\t\\tChart.animationService.addAnimation(this, animation, duration, lazy);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.draw();\\n\\t\\t\\t\\tif (this.options.animation && this.options.animation.onComplete && this.options.animation.onComplete.call) {\\n\\t\\t\\t\\t\\tthis.options.animation.onComplete.call(this);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\t\\t\\tthis.clear();\\n\\n\\t\\t\\t// Draw all the scales\\n\\t\\t\\thelpers.each(this.boxes, function(box) {\\n\\t\\t\\t\\tbox.draw(this.chartArea);\\n\\t\\t\\t}, this);\\n\\t\\t\\tif (this.scale) {\\n\\t\\t\\t\\tthis.scale.draw();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Clip out the chart area so that anything outside does not draw. This is necessary for zoom and pan to function\\n\\t\\t\\tthis.chart.ctx.save();\\n\\t\\t\\tthis.chart.ctx.beginPath();\\n\\t\\t\\tthis.chart.ctx.rect(this.chartArea.left, this.chartArea.top, this.chartArea.right - this.chartArea.left, this.chartArea.bottom - this.chartArea.top);\\n\\t\\t\\tthis.chart.ctx.clip();\\n\\n\\t\\t\\t// Draw each dataset via its respective controller (reversed to support proper line stacking)\\n\\t\\t\\thelpers.each(this.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tif (helpers.isDatasetVisible(dataset)) {\\n\\t\\t\\t\\t\\tdataset.controller.draw(ease);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, null, true);\\n\\n\\t\\t\\t// Restore from the clipping operation\\n\\t\\t\\tthis.chart.ctx.restore();\\n\\n\\t\\t\\t// Finally draw the tooltip\\n\\t\\t\\tthis.tooltip.transition(easingDecimal).draw();\\n\\t\\t},\\n\\n\\t\\t// Get the single element that was clicked on\\n\\t\\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\\n\\t\\tgetElementAtEvent: function(e) {\\n\\n\\t\\t\\tvar eventPosition = helpers.getRelativePosition(e, this.chart);\\n\\t\\t\\tvar elementsArray = [];\\n\\n\\t\\t\\thelpers.each(this.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tif (helpers.isDatasetVisible(dataset)) {\\n\\t\\t\\t\\t\\thelpers.each(dataset.metaData, function(element, index) {\\n\\t\\t\\t\\t\\t\\tif (element.inRange(eventPosition.x, eventPosition.y)) {\\n\\t\\t\\t\\t\\t\\t\\telementsArray.push(element);\\n\\t\\t\\t\\t\\t\\t\\treturn elementsArray;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\treturn elementsArray;\\n\\t\\t},\\n\\n\\t\\tgetElementsAtEvent: function(e) {\\n\\t\\t\\tvar eventPosition = helpers.getRelativePosition(e, this.chart);\\n\\t\\t\\tvar elementsArray = [];\\n\\n\\t\\t\\tvar found = (function() {\\n\\t\\t\\t\\tif (this.data.datasets) {\\n\\t\\t\\t\\t\\tfor (var i = 0; i < this.data.datasets.length; i++) {\\n\\t\\t\\t\\t\\t\\tif (helpers.isDatasetVisible(this.data.datasets[i])) {\\n\\t\\t\\t\\t\\t\\t\\tfor (var j = 0; j < this.data.datasets[i].metaData.length; j++) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (this.data.datasets[i].metaData[j].inRange(eventPosition.x, eventPosition.y)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn this.data.datasets[i].metaData[j];\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}).call(this);\\n\\n\\t\\t\\tif (!found) {\\n\\t\\t\\t\\treturn elementsArray;\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(this.data.datasets, function(dataset, dsIndex) {\\n\\t\\t\\t\\tif (helpers.isDatasetVisible(dataset)) {\\n\\t\\t\\t\\t\\telementsArray.push(dataset.metaData[found._index]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\treturn elementsArray;\\n\\t\\t},\\n\\n\\t\\tgetDatasetAtEvent: function(e) {\\n\\t\\t\\tvar elementsArray = this.getElementAtEvent(e);\\n\\n\\t\\t\\tif (elementsArray.length > 0) {\\n\\t\\t\\t\\telementsArray = this.data.datasets[elementsArray[0]._datasetIndex].metaData;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elementsArray;\\n\\t\\t},\\n\\n\\t\\tgenerateLegend: function generateLegend() {\\n\\t\\t\\treturn this.options.legendCallback(this);\\n\\t\\t},\\n\\n\\t\\tdestroy: function destroy() {\\n\\t\\t\\tthis.clear();\\n\\t\\t\\thelpers.unbindEvents(this, this.events);\\n\\t\\t\\thelpers.removeResizeListener(this.chart.canvas.parentNode);\\n\\n\\t\\t\\t// Reset canvas height/width attributes\\n\\t\\t\\tvar canvas = this.chart.canvas;\\n\\t\\t\\tcanvas.width = this.chart.width;\\n\\t\\t\\tcanvas.height = this.chart.height;\\n\\n\\t\\t\\t// if we scaled the canvas in response to a devicePixelRatio !== 1, we need to undo that transform here\\n\\t\\t\\tif (this.chart.originalDevicePixelRatio !== undefined) {\\n\\t\\t\\t\\tthis.chart.ctx.scale(1 / this.chart.originalDevicePixelRatio, 1 / this.chart.originalDevicePixelRatio);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reset to the old style since it may have been changed by the device pixel ratio changes\\n\\t\\t\\tcanvas.style.width = this.chart.originalCanvasStyleWidth;\\n\\t\\t\\tcanvas.style.height = this.chart.originalCanvasStyleHeight;\\n\\n\\t\\t\\tdelete Chart.instances[this.id];\\n\\t\\t},\\n\\n\\t\\ttoBase64Image: function toBase64Image() {\\n\\t\\t\\treturn this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);\\n\\t\\t},\\n\\n\\t\\tinitToolTip: function initToolTip() {\\n\\t\\t\\tthis.tooltip = new Chart.Tooltip({\\n\\t\\t\\t\\t_chart: this.chart,\\n\\t\\t\\t\\t_chartInstance: this,\\n\\t\\t\\t\\t_data: this.data,\\n\\t\\t\\t\\t_options: this.options\\n\\t\\t\\t}, this);\\n\\t\\t},\\n\\n\\t\\tbindEvents: function bindEvents() {\\n\\t\\t\\thelpers.bindEvents(this, this.options.events, function(evt) {\\n\\t\\t\\t\\tthis.eventHandler(evt);\\n\\t\\t\\t});\\n\\t\\t},\\n\\t\\teventHandler: function eventHandler(e) {\\n\\t\\t\\tthis.lastActive = this.lastActive || [];\\n\\t\\t\\tthis.lastTooltipActive = this.lastTooltipActive || [];\\n\\n\\t\\t\\t// Find Active Elements for hover and tooltips\\n\\t\\t\\tif (e.type === 'mouseout') {\\n\\t\\t\\t\\tthis.active = [];\\n\\t\\t\\t\\tthis.tooltipActive = [];\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar _this = this;\\n\\t\\t\\t\\tvar getItemsForMode = function(mode) {\\n\\t\\t\\t\\t\\tswitch (mode) {\\n\\t\\t\\t\\t\\t\\tcase 'single':\\n\\t\\t\\t\\t\\t\\t\\treturn _this.getElementAtEvent(e);\\n\\t\\t\\t\\t\\t\\tcase 'label':\\n\\t\\t\\t\\t\\t\\t\\treturn _this.getElementsAtEvent(e);\\n\\t\\t\\t\\t\\t\\tcase 'dataset':\\n\\t\\t\\t\\t\\t\\t\\treturn _this.getDatasetAtEvent(e);\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\treturn e;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tthis.active = getItemsForMode(this.options.hover.mode);\\n\\t\\t\\t\\tthis.tooltipActive = getItemsForMode(this.options.tooltips.mode);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// On Hover hook\\n\\t\\t\\tif (this.options.hover.onHover) {\\n\\t\\t\\t\\tthis.options.hover.onHover.call(this, this.active);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (e.type === 'mouseup' || e.type === 'click') {\\n\\t\\t\\t\\tif (this.options.onClick) {\\n\\t\\t\\t\\t\\tthis.options.onClick.call(this, e, this.active);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (this.legend && this.legend.handleEvent) {\\n\\t\\t\\t\\t\\tthis.legend.handleEvent(e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar dataset;\\n\\t\\t\\tvar index;\\n\\n\\t\\t\\t// Remove styling for last active (even if it may still be active)\\n\\t\\t\\tif (this.lastActive.length) {\\n\\t\\t\\t\\tswitch (this.options.hover.mode) {\\n\\t\\t\\t\\t\\tcase 'single':\\n\\t\\t\\t\\t\\t\\tthis.data.datasets[this.lastActive[0]._datasetIndex].controller.removeHoverStyle(this.lastActive[0], this.lastActive[0]._datasetIndex, this.lastActive[0]._index);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 'label':\\n\\t\\t\\t\\t\\tcase 'dataset':\\n\\t\\t\\t\\t\\t\\tfor (var i = 0; i < this.lastActive.length; i++) {\\n\\t\\t\\t\\t\\t\\t\\tif (this.lastActive[i])\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.data.datasets[this.lastActive[i]._datasetIndex].controller.removeHoverStyle(this.lastActive[i], this.lastActive[i]._datasetIndex, this.lastActive[i]._index);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t// Don't change anything\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Built in hover styling\\n\\t\\t\\tif (this.active.length && this.options.hover.mode) {\\n\\t\\t\\t\\tswitch (this.options.hover.mode) {\\n\\t\\t\\t\\t\\tcase 'single':\\n\\t\\t\\t\\t\\t\\tthis.data.datasets[this.active[0]._datasetIndex].controller.setHoverStyle(this.active[0]);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 'label':\\n\\t\\t\\t\\t\\tcase 'dataset':\\n\\t\\t\\t\\t\\t\\tfor (var j = 0; j < this.active.length; j++) {\\n\\t\\t\\t\\t\\t\\t\\tif (this.active[j])\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.data.datasets[this.active[j]._datasetIndex].controller.setHoverStyle(this.active[j]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t// Don't change anything\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// Built in Tooltips\\n\\t\\t\\tif (this.options.tooltips.enabled || this.options.tooltips.custom) {\\n\\n\\t\\t\\t\\t// The usual updates\\n\\t\\t\\t\\tthis.tooltip.initialize();\\n\\t\\t\\t\\tthis.tooltip._active = this.tooltipActive;\\n\\t\\t\\t\\tthis.tooltip.update();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Hover animations\\n\\t\\t\\tthis.tooltip.pivot();\\n\\n\\t\\t\\tif (!this.animating) {\\n\\t\\t\\t\\tvar changed;\\n\\n\\t\\t\\t\\thelpers.each(this.active, function(element, index) {\\n\\t\\t\\t\\t\\tif (element !== this.lastActive[index]) {\\n\\t\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}, this);\\n\\n\\t\\t\\t\\thelpers.each(this.tooltipActive, function(element, index) {\\n\\t\\t\\t\\t\\tif (element !== this.lastTooltipActive[index]) {\\n\\t\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}, this);\\n\\n\\t\\t\\t\\t// If entering, leaving, or changing elements, animate the change via pivot\\n\\t\\t\\t\\tif ((this.lastActive.length !== this.active.length) ||\\n\\t\\t\\t\\t\\t(this.lastTooltipActive.length !== this.tooltipActive.length) ||\\n\\t\\t\\t\\t\\tchanged) {\\n\\n\\t\\t\\t\\t\\tthis.stop();\\n\\n\\t\\t\\t\\t\\tif (this.options.tooltips.enabled || this.options.tooltips.custom) {\\n\\t\\t\\t\\t\\t\\tthis.tooltip.update(true);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// We only need to render at this point. Updating will cause scales to be recomputed generating flicker & using more\\n\\t\\t\\t\\t\\t// memory than necessary.\\n\\t\\t\\t\\t\\tthis.render(this.options.hover.animationDuration, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remember Last Actives\\n\\t\\t\\tthis.lastActive = this.active;\\n\\t\\t\\tthis.lastTooltipActive = this.tooltipActive;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],23:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\t// Base class for all dataset controllers (line, bar, etc)\\n\\tChart.DatasetController = function(chart, datasetIndex) {\\n\\t\\tthis.initialize.call(this, chart, datasetIndex);\\n\\t};\\n\\n\\thelpers.extend(Chart.DatasetController.prototype, {\\n\\t\\tinitialize: function(chart, datasetIndex) {\\n\\t\\t\\tthis.chart = chart;\\n\\t\\t\\tthis.index = datasetIndex;\\n\\t\\t\\tthis.linkScales();\\n\\t\\t\\tthis.addElements();\\n\\t\\t},\\n\\t\\tupdateIndex: function(datasetIndex) {\\n\\t\\t\\tthis.index = datasetIndex;\\n\\t\\t},\\n\\n\\t\\tlinkScales: function() {\\n\\t\\t\\tif (!this.getDataset().xAxisID) {\\n\\t\\t\\t\\tthis.getDataset().xAxisID = this.chart.options.scales.xAxes[0].id;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!this.getDataset().yAxisID) {\\n\\t\\t\\t\\tthis.getDataset().yAxisID = this.chart.options.scales.yAxes[0].id;\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tgetDataset: function() {\\n\\t\\t\\treturn this.chart.data.datasets[this.index];\\n\\t\\t},\\n\\n\\t\\tgetScaleForId: function(scaleID) {\\n\\t\\t\\treturn this.chart.scales[scaleID];\\n\\t\\t},\\n\\n\\t\\treset: function() {\\n\\t\\t\\tthis.update(true);\\n\\t\\t},\\n\\n\\t\\tbuildOrUpdateElements: function buildOrUpdateElements() {\\n\\t\\t\\t// Handle the number of data points changing\\n\\t\\t\\tvar numData = this.getDataset().data.length;\\n\\t\\t\\tvar numMetaData = this.getDataset().metaData.length;\\n\\n\\t\\t\\t// Make sure that we handle number of datapoints changing\\n\\t\\t\\tif (numData < numMetaData) {\\n\\t\\t\\t\\t// Remove excess bars for data points that have been removed\\n\\t\\t\\t\\tthis.getDataset().metaData.splice(numData, numMetaData - numData);\\n\\t\\t\\t} else if (numData > numMetaData) {\\n\\t\\t\\t\\t// Add new elements\\n\\t\\t\\t\\tfor (var index = numMetaData; index < numData; ++index) {\\n\\t\\t\\t\\t\\tthis.addElementAndReset(index);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Controllers should implement the following\\n\\t\\taddElements: helpers.noop,\\n\\t\\taddElementAndReset: helpers.noop,\\n\\t\\tdraw: helpers.noop,\\n\\t\\tremoveHoverStyle: helpers.noop,\\n\\t\\tsetHoverStyle: helpers.noop,\\n\\t\\tupdate: helpers.noop\\n\\t});\\n\\n\\tChart.DatasetController.extend = helpers.inherits;\\n\\n};\\n},{}],24:[function(require,module,exports){\\n\\\"use strict\\\";\\n\\nmodule.exports = function(Chart) {\\n\\n  var helpers = Chart.helpers;\\n\\n  Chart.elements = {};\\n\\n  Chart.Element = function(configuration) {\\n    helpers.extend(this, configuration);\\n    this.initialize.apply(this, arguments);\\n  };\\n  helpers.extend(Chart.Element.prototype, {\\n    initialize: function() {},\\n    pivot: function() {\\n      if (!this._view) {\\n        this._view = helpers.clone(this._model);\\n      }\\n      this._start = helpers.clone(this._view);\\n      return this;\\n    },\\n    transition: function(ease) {\\n      if (!this._view) {\\n        this._view = helpers.clone(this._model);\\n      }\\n\\n      // No animation -> No Transition\\n      if (ease === 1) {\\n        this._view = this._model;\\n        this._start = null;\\n        return this;\\n      }\\n\\n      if (!this._start) {\\n        this.pivot();\\n      }\\n\\n      helpers.each(this._model, function(value, key) {\\n\\n        if (key[0] === '_' || !this._model.hasOwnProperty(key)) {\\n          // Only non-underscored properties\\n        }\\n\\n        // Init if doesn't exist\\n        else if (!this._view.hasOwnProperty(key)) {\\n          if (typeof value === 'number' && !isNaN(this._view[key])) {\\n            this._view[key] = value * ease;\\n          } else {\\n            this._view[key] = value;\\n          }\\n        }\\n\\n        // No unnecessary computations\\n        else if (value === this._view[key]) {\\n          // It's the same! Woohoo!\\n        }\\n\\n        // Color transitions if possible\\n        else if (typeof value === 'string') {\\n          try {\\n            var color = helpers.color(this._start[key]).mix(helpers.color(this._model[key]), ease);\\n            this._view[key] = color.rgbString();\\n          } catch (err) {\\n            this._view[key] = value;\\n          }\\n        }\\n        // Number transitions\\n        else if (typeof value === 'number') {\\n          var startVal = this._start[key] !== undefined && isNaN(this._start[key]) === false ? this._start[key] : 0;\\n          this._view[key] = ((this._model[key] - startVal) * ease) + startVal;\\n        }\\n        // Everything else\\n        else {\\n          this._view[key] = value;\\n        }\\n      }, this);\\n\\n      return this;\\n    },\\n    tooltipPosition: function() {\\n      return {\\n        x: this._model.x,\\n        y: this._model.y\\n      };\\n    },\\n    hasValue: function() {\\n      return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\\n    }\\n  });\\n\\n  Chart.Element.extend = helpers.inherits;\\n\\n};\\n\\n},{}],25:[function(require,module,exports){\\n/*global window: false */\\n/*global document: false */\\n\\\"use strict\\\";\\n\\nvar color = require('chartjs-color');\\n\\nmodule.exports = function(Chart) {\\n\\n\\t//Global Chart helpers object for utility methods and classes\\n\\tvar helpers = Chart.helpers = {};\\n\\n\\t//-- Basic js utility methods\\n\\thelpers.each = function(loopable, callback, self, reverse) {\\n\\t\\t// Check to see if null or undefined firstly.\\n\\t\\tvar i, len;\\n\\t\\tif (helpers.isArray(loopable)) {\\n\\t\\t\\tlen = loopable.length;\\n\\t\\t\\tif (reverse) {\\n\\t\\t\\t\\tfor (i = len - 1; i >= 0; i--) {\\n\\t\\t\\t\\t\\tcallback.call(self, loopable[i], i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\t\\tcallback.call(self, loopable[i], i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if (typeof loopable === 'object') {\\n\\t\\t\\tvar keys = Object.keys(loopable);\\n\\t\\t\\tlen = keys.length;\\n\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\tcallback.call(self, loopable[keys[i]], keys[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.clone = function(obj) {\\n\\t\\tvar objClone = {};\\n\\t\\thelpers.each(obj, function(value, key) {\\n\\t\\t\\tif (obj.hasOwnProperty(key)) {\\n\\t\\t\\t\\tif (helpers.isArray(value)) {\\n\\t\\t\\t\\t\\tobjClone[key] = value.slice(0);\\n\\t\\t\\t\\t} else if (typeof value === 'object' && value !== null) {\\n\\t\\t\\t\\t\\tobjClone[key] = helpers.clone(value);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tobjClone[key] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn objClone;\\n\\t};\\n\\thelpers.extend = function(base) {\\n\\t\\tvar len = arguments.length;\\n\\t\\tvar additionalArgs = [];\\n\\t\\tfor (var i = 1; i < len; i++) {\\n\\t\\t\\tadditionalArgs.push(arguments[i]);\\n\\t\\t}\\n\\t\\thelpers.each(additionalArgs, function(extensionObject) {\\n\\t\\t\\thelpers.each(extensionObject, function(value, key) {\\n\\t\\t\\t\\tif (extensionObject.hasOwnProperty(key)) {\\n\\t\\t\\t\\t\\tbase[key] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\t\\treturn base;\\n\\t};\\n\\t// Need a special merge function to chart configs since they are now grouped\\n\\thelpers.configMerge = function(_base) {\\n\\t\\tvar base = helpers.clone(_base);\\n\\t\\thelpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {\\n\\t\\t\\thelpers.each(extension, function(value, key) {\\n\\t\\t\\t\\tif (extension.hasOwnProperty(key)) {\\n\\t\\t\\t\\t\\tif (key === 'scales') {\\n\\t\\t\\t\\t\\t\\t// Scale config merging is complex. Add out own function here for that\\n\\t\\t\\t\\t\\t\\tbase[key] = helpers.scaleMerge(base.hasOwnProperty(key) ? base[key] : {}, value);\\n\\n\\t\\t\\t\\t\\t} else if (key === 'scale') {\\n\\t\\t\\t\\t\\t\\t// Used in polar area & radar charts since there is only one scale\\n\\t\\t\\t\\t\\t\\tbase[key] = helpers.configMerge(base.hasOwnProperty(key) ? base[key] : {}, Chart.scaleService.getScaleDefaults(value.type), value);\\n\\t\\t\\t\\t\\t} else if (base.hasOwnProperty(key) && helpers.isArray(base[key]) && helpers.isArray(value)) {\\n\\t\\t\\t\\t\\t\\t// In this case we have an array of objects replacing another array. Rather than doing a strict replace,\\n\\t\\t\\t\\t\\t\\t// merge. This allows easy scale option merging\\n\\t\\t\\t\\t\\t\\tvar baseArray = base[key];\\n\\n\\t\\t\\t\\t\\t\\thelpers.each(value, function(valueObj, index) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif (index < baseArray.length) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (typeof baseArray[index] === 'object' && baseArray[index] !== null && typeof valueObj === 'object' && valueObj !== null) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Two objects are coming together. Do a merge of them.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbaseArray[index] = helpers.configMerge(baseArray[index], valueObj);\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Just overwrite in this case since there is nothing to merge\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbaseArray[index] = valueObj;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tbaseArray.push(valueObj); // nothing to merge\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\t} else if (base.hasOwnProperty(key) && typeof base[key] === \\\"object\\\" && base[key] !== null && typeof value === \\\"object\\\") {\\n\\t\\t\\t\\t\\t\\t// If we are overwriting an object with an object, do a merge of the properties.\\n\\t\\t\\t\\t\\t\\tbase[key] = helpers.configMerge(base[key], value);\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// can just overwrite the value in this case\\n\\t\\t\\t\\t\\t\\tbase[key] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treturn base;\\n\\t};\\n\\thelpers.extendDeep = function(_base) {\\n\\t\\treturn _extendDeep.apply(this, arguments);\\n\\n\\t\\tfunction _extendDeep(dst) {\\n\\t\\t\\thelpers.each(arguments, function(obj) {\\n\\t\\t\\t\\tif (obj !== dst) {\\n\\t\\t\\t\\t\\thelpers.each(obj, function(value, key) {\\n\\t\\t\\t\\t\\t\\tif (dst[key] && dst[key].constructor && dst[key].constructor === Object) {\\n\\t\\t\\t\\t\\t\\t\\t_extendDeep(dst[key], value);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tdst[key] = value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn dst;\\n\\t\\t}\\n\\t};\\n\\thelpers.scaleMerge = function(_base, extension) {\\n\\t\\tvar base = helpers.clone(_base);\\n\\n\\t\\thelpers.each(extension, function(value, key) {\\n\\t\\t\\tif (extension.hasOwnProperty(key)) {\\n\\t\\t\\t\\tif (key === 'xAxes' || key === 'yAxes') {\\n\\t\\t\\t\\t\\t// These properties are arrays of items\\n\\t\\t\\t\\t\\tif (base.hasOwnProperty(key)) {\\n\\t\\t\\t\\t\\t\\thelpers.each(value, function(valueObj, index) {\\n\\t\\t\\t\\t\\t\\t\\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\\n\\t\\t\\t\\t\\t\\t\\tvar axisDefaults = Chart.scaleService.getScaleDefaults(axisType);\\n\\t\\t\\t\\t\\t\\t\\tif (index >= base[key].length || !base[key][index].type) {\\n\\t\\t\\t\\t\\t\\t\\t\\tbase[key].push(helpers.configMerge(axisDefaults, valueObj));\\n\\t\\t\\t\\t\\t\\t\\t} else if (valueObj.type && valueObj.type !== base[key][index].type) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults\\n\\t\\t\\t\\t\\t\\t\\t\\tbase[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Type is the same\\n\\t\\t\\t\\t\\t\\t\\t\\tbase[key][index] = helpers.configMerge(base[key][index], valueObj);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbase[key] = [];\\n\\t\\t\\t\\t\\t\\thelpers.each(value, function(valueObj) {\\n\\t\\t\\t\\t\\t\\t\\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\\n\\t\\t\\t\\t\\t\\t\\tbase[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (base.hasOwnProperty(key) && typeof base[key] === \\\"object\\\" && base[key] !== null && typeof value === \\\"object\\\") {\\n\\t\\t\\t\\t\\t// If we are overwriting an object with an object, do a merge of the properties.\\n\\t\\t\\t\\t\\tbase[key] = helpers.configMerge(base[key], value);\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// can just overwrite the value in this case\\n\\t\\t\\t\\t\\tbase[key] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn base;\\n\\t};\\n\\thelpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {\\n\\t\\tif (value === undefined || value === null) {\\n\\t\\t\\treturn defaultValue;\\n\\t\\t}\\n\\n\\t\\tif (helpers.isArray(value)) {\\n\\t\\t\\treturn index < value.length ? value[index] : defaultValue;\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t};\\n\\thelpers.getValueOrDefault = function(value, defaultValue) {\\n\\t\\treturn value === undefined ? defaultValue : value;\\n\\t};\\n\\thelpers.indexOf = function(arrayToSearch, item) {\\n\\t\\tif (Array.prototype.indexOf) {\\n\\t\\t\\treturn arrayToSearch.indexOf(item);\\n\\t\\t} else {\\n\\t\\t\\tfor (var i = 0; i < arrayToSearch.length; i++) {\\n\\t\\t\\t\\tif (arrayToSearch[i] === item)\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\thelpers.where = function(collection, filterCallback) {\\n\\t\\tvar filtered = [];\\n\\n\\t\\thelpers.each(collection, function(item) {\\n\\t\\t\\tif (filterCallback(item)) {\\n\\t\\t\\t\\tfiltered.push(item);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn filtered;\\n\\t};\\n\\thelpers.findIndex = function(arrayToSearch, callback, thisArg) {\\n\\t\\tvar index = -1;\\n\\t\\tif (Array.prototype.findIndex) {\\n\\t\\t\\tindex = arrayToSearch.findIndex(callback, thisArg);\\n\\t\\t} else {\\n\\t\\t\\tfor (var i = 0; i < arrayToSearch.length; ++i) {\\n\\t\\t\\t\\tthisArg = thisArg !== undefined ? thisArg : arrayToSearch;\\n\\n\\t\\t\\t\\tif (callback.call(thisArg, arrayToSearch[i], i, arrayToSearch)) {\\n\\t\\t\\t\\t\\tindex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn index;\\n\\t};\\n\\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\\n\\t\\t// Default to start of the array\\n\\t\\tif (startIndex === undefined || startIndex === null) {\\n\\t\\t\\tstartIndex = -1;\\n\\t\\t}\\n\\t\\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\\n\\t\\t\\tvar currentItem = arrayToSearch[i];\\n\\t\\t\\tif (filterCallback(currentItem)) {\\n\\t\\t\\t\\treturn currentItem;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\\n\\t\\t// Default to end of the array\\n\\t\\tif (startIndex === undefined || startIndex === null) {\\n\\t\\t\\tstartIndex = arrayToSearch.length;\\n\\t\\t}\\n\\t\\tfor (var i = startIndex - 1; i >= 0; i--) {\\n\\t\\t\\tvar currentItem = arrayToSearch[i];\\n\\t\\t\\tif (filterCallback(currentItem)) {\\n\\t\\t\\t\\treturn currentItem;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.inherits = function(extensions) {\\n\\t\\t//Basic javascript inheritance based on the model created in Backbone.js\\n\\t\\tvar parent = this;\\n\\t\\tvar ChartElement = (extensions && extensions.hasOwnProperty(\\\"constructor\\\")) ? extensions.constructor : function() {\\n\\t\\t\\treturn parent.apply(this, arguments);\\n\\t\\t};\\n\\n\\t\\tvar Surrogate = function() {\\n\\t\\t\\tthis.constructor = ChartElement;\\n\\t\\t};\\n\\t\\tSurrogate.prototype = parent.prototype;\\n\\t\\tChartElement.prototype = new Surrogate();\\n\\n\\t\\tChartElement.extend = helpers.inherits;\\n\\n\\t\\tif (extensions) {\\n\\t\\t\\thelpers.extend(ChartElement.prototype, extensions);\\n\\t\\t}\\n\\n\\t\\tChartElement.__super__ = parent.prototype;\\n\\n\\t\\treturn ChartElement;\\n\\t};\\n\\thelpers.noop = function() {};\\n\\thelpers.uid = (function() {\\n\\t\\tvar id = 0;\\n\\t\\treturn function() {\\n\\t\\t\\treturn \\\"chart-\\\" + id++;\\n\\t\\t};\\n\\t})();\\n\\thelpers.warn = function(str) {\\n\\t\\t//Method for warning of errors\\n\\t\\tif (console && typeof console.warn === \\\"function\\\") {\\n\\t\\t\\tconsole.warn(str);\\n\\t\\t}\\n\\t};\\n\\t//-- Math methods\\n\\thelpers.isNumber = function(n) {\\n\\t\\treturn !isNaN(parseFloat(n)) && isFinite(n);\\n\\t};\\n\\thelpers.almostEquals = function(x, y, epsilon) {\\n\\t\\treturn Math.abs(x - y) < epsilon;\\n\\t};\\n\\thelpers.max = function(array) {\\n\\t\\treturn array.reduce(function(max, value) {\\n\\t\\t\\tif (!isNaN(value)) {\\n\\t\\t\\t\\treturn Math.max(max, value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn max;\\n\\t\\t\\t}\\n\\t\\t}, Number.NEGATIVE_INFINITY);\\n\\t};\\n\\thelpers.min = function(array) {\\n\\t\\treturn array.reduce(function(min, value) {\\n\\t\\t\\tif (!isNaN(value)) {\\n\\t\\t\\t\\treturn Math.min(min, value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn min;\\n\\t\\t\\t}\\n\\t\\t}, Number.POSITIVE_INFINITY);\\n\\t};\\n\\thelpers.sign = function(x) {\\n\\t\\tif (Math.sign) {\\n\\t\\t\\treturn Math.sign(x);\\n\\t\\t} else {\\n\\t\\t\\tx = +x; // convert to a number\\n\\t\\t\\tif (x === 0 || isNaN(x)) {\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}\\n\\t\\t\\treturn x > 0 ? 1 : -1;\\n\\t\\t}\\n\\t};\\n\\thelpers.log10 = function(x) {\\n\\t\\tif (Math.log10) {\\n\\t\\t\\treturn Math.log10(x);\\n\\t\\t} else {\\n\\t\\t\\treturn Math.log(x) / Math.LN10;\\n\\t\\t}\\n\\t};\\n\\thelpers.toRadians = function(degrees) {\\n\\t\\treturn degrees * (Math.PI / 180);\\n\\t};\\n\\thelpers.toDegrees = function(radians) {\\n\\t\\treturn radians * (180 / Math.PI);\\n\\t};\\n\\t// Gets the angle from vertical upright to the point about a centre.\\n\\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\\n\\t\\tvar distanceFromXCenter = anglePoint.x - centrePoint.x,\\n\\t\\t\\tdistanceFromYCenter = anglePoint.y - centrePoint.y,\\n\\t\\t\\tradialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\\n\\n\\t\\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\\n\\n\\t\\tif (angle < (-0.5 * Math.PI)) {\\n\\t\\t\\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tangle: angle,\\n\\t\\t\\tdistance: radialDistanceFromCenter\\n\\t\\t};\\n\\t};\\n\\thelpers.aliasPixel = function(pixelWidth) {\\n\\t\\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\\n\\t};\\n\\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\\n\\t\\t//Props to Rob Spencer at scaled innovation for his post on splining between points\\n\\t\\t//http://scaledinnovation.com/analytics/splines/aboutSplines.html\\n\\n\\t\\t// This function must also respect \\\"skipped\\\" points\\n\\n\\t\\tvar previous = firstPoint.skip ? middlePoint : firstPoint,\\n\\t\\t\\tcurrent = middlePoint,\\n\\t\\t\\tnext = afterPoint.skip ? middlePoint : afterPoint;\\n\\n\\t\\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\\n\\t\\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\\n\\n\\t\\tvar s01 = d01 / (d01 + d12);\\n\\t\\tvar s12 = d12 / (d01 + d12);\\n\\n\\t\\t// If all points are the same, s01 & s02 will be inf\\n\\t\\ts01 = isNaN(s01) ? 0 : s01;\\n\\t\\ts12 = isNaN(s12) ? 0 : s12;\\n\\n\\t\\tvar fa = t * s01; // scaling factor for triangle Ta\\n\\t\\tvar fb = t * s12;\\n\\n\\t\\treturn {\\n\\t\\t\\tprevious: {\\n\\t\\t\\t\\tx: current.x - fa * (next.x - previous.x),\\n\\t\\t\\t\\ty: current.y - fa * (next.y - previous.y)\\n\\t\\t\\t},\\n\\t\\t\\tnext: {\\n\\t\\t\\t\\tx: current.x + fb * (next.x - previous.x),\\n\\t\\t\\t\\ty: current.y + fb * (next.y - previous.y)\\n\\t\\t\\t}\\n\\t\\t};\\n\\t};\\n\\thelpers.nextItem = function(collection, index, loop) {\\n\\t\\tif (loop) {\\n\\t\\t\\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\\n\\t\\t}\\n\\n\\t\\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\\n\\t};\\n\\thelpers.previousItem = function(collection, index, loop) {\\n\\t\\tif (loop) {\\n\\t\\t\\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\\n\\t\\t}\\n\\t\\treturn index <= 0 ? collection[0] : collection[index - 1];\\n\\t};\\n\\t// Implementation of the nice number algorithm used in determining where axis labels will go\\n\\thelpers.niceNum = function(range, round) {\\n\\t\\tvar exponent = Math.floor(helpers.log10(range));\\n\\t\\tvar fraction = range / Math.pow(10, exponent);\\n\\t\\tvar niceFraction;\\n\\n\\t\\tif (round) {\\n\\t\\t\\tif (fraction < 1.5) {\\n\\t\\t\\t\\tniceFraction = 1;\\n\\t\\t\\t} else if (fraction < 3) {\\n\\t\\t\\t\\tniceFraction = 2;\\n\\t\\t\\t} else if (fraction < 7) {\\n\\t\\t\\t\\tniceFraction = 5;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tniceFraction = 10;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (fraction <= 1.0) {\\n\\t\\t\\t\\tniceFraction = 1;\\n\\t\\t\\t} else if (fraction <= 2) {\\n\\t\\t\\t\\tniceFraction = 2;\\n\\t\\t\\t} else if (fraction <= 5) {\\n\\t\\t\\t\\tniceFraction = 5;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tniceFraction = 10;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn niceFraction * Math.pow(10, exponent);\\n\\t};\\n\\t//Easing functions adapted from Robert Penner's easing equations\\n\\t//http://www.robertpenner.com/easing/\\n\\tvar easingEffects = helpers.easingEffects = {\\n\\t\\tlinear: function(t) {\\n\\t\\t\\treturn t;\\n\\t\\t},\\n\\t\\teaseInQuad: function(t) {\\n\\t\\t\\treturn t * t;\\n\\t\\t},\\n\\t\\teaseOutQuad: function(t) {\\n\\t\\t\\treturn -1 * t * (t - 2);\\n\\t\\t},\\n\\t\\teaseInOutQuad: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1 / 2 * ((--t) * (t - 2) - 1);\\n\\t\\t},\\n\\t\\teaseInCubic: function(t) {\\n\\t\\t\\treturn t * t * t;\\n\\t\\t},\\n\\t\\teaseOutCubic: function(t) {\\n\\t\\t\\treturn 1 * ((t = t / 1 - 1) * t * t + 1);\\n\\t\\t},\\n\\t\\teaseInOutCubic: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * ((t -= 2) * t * t + 2);\\n\\t\\t},\\n\\t\\teaseInQuart: function(t) {\\n\\t\\t\\treturn t * t * t * t;\\n\\t\\t},\\n\\t\\teaseOutQuart: function(t) {\\n\\t\\t\\treturn -1 * ((t = t / 1 - 1) * t * t * t - 1);\\n\\t\\t},\\n\\t\\teaseInOutQuart: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1 / 2 * ((t -= 2) * t * t * t - 2);\\n\\t\\t},\\n\\t\\teaseInQuint: function(t) {\\n\\t\\t\\treturn 1 * (t /= 1) * t * t * t * t;\\n\\t\\t},\\n\\t\\teaseOutQuint: function(t) {\\n\\t\\t\\treturn 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\\n\\t\\t},\\n\\t\\teaseInOutQuint: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t * t * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * ((t -= 2) * t * t * t * t + 2);\\n\\t\\t},\\n\\t\\teaseInSine: function(t) {\\n\\t\\t\\treturn -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\\n\\t\\t},\\n\\t\\teaseOutSine: function(t) {\\n\\t\\t\\treturn 1 * Math.sin(t / 1 * (Math.PI / 2));\\n\\t\\t},\\n\\t\\teaseInOutSine: function(t) {\\n\\t\\t\\treturn -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);\\n\\t\\t},\\n\\t\\teaseInExpo: function(t) {\\n\\t\\t\\treturn (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\\n\\t\\t},\\n\\t\\teaseOutExpo: function(t) {\\n\\t\\t\\treturn (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\\n\\t\\t},\\n\\t\\teaseInOutExpo: function(t) {\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif (t === 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * Math.pow(2, 10 * (t - 1));\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * (-Math.pow(2, -10 * --t) + 2);\\n\\t\\t},\\n\\t\\teaseInCirc: function(t) {\\n\\t\\t\\tif (t >= 1) {\\n\\t\\t\\t\\treturn t;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\\n\\t\\t},\\n\\t\\teaseOutCirc: function(t) {\\n\\t\\t\\treturn 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\\n\\t\\t},\\n\\t\\teaseInOutCirc: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn -1 / 2 * (Math.sqrt(1 - t * t) - 1);\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);\\n\\t\\t},\\n\\t\\teaseInElastic: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tvar p = 0;\\n\\t\\t\\tvar a = 1;\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1) === 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (!p) {\\n\\t\\t\\t\\tp = 1 * 0.3;\\n\\t\\t\\t}\\n\\t\\t\\tif (a < Math.abs(1)) {\\n\\t\\t\\t\\ta = 1;\\n\\t\\t\\t\\ts = p / 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = p / (2 * Math.PI) * Math.asin(1 / a);\\n\\t\\t\\t}\\n\\t\\t\\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\\n\\t\\t},\\n\\t\\teaseOutElastic: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tvar p = 0;\\n\\t\\t\\tvar a = 1;\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1) === 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (!p) {\\n\\t\\t\\t\\tp = 1 * 0.3;\\n\\t\\t\\t}\\n\\t\\t\\tif (a < Math.abs(1)) {\\n\\t\\t\\t\\ta = 1;\\n\\t\\t\\t\\ts = p / 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = p / (2 * Math.PI) * Math.asin(1 / a);\\n\\t\\t\\t}\\n\\t\\t\\treturn a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;\\n\\t\\t},\\n\\t\\teaseInOutElastic: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tvar p = 0;\\n\\t\\t\\tvar a = 1;\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1 / 2) === 2) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (!p) {\\n\\t\\t\\t\\tp = 1 * (0.3 * 1.5);\\n\\t\\t\\t}\\n\\t\\t\\tif (a < Math.abs(1)) {\\n\\t\\t\\t\\ta = 1;\\n\\t\\t\\t\\ts = p / 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = p / (2 * Math.PI) * Math.asin(1 / a);\\n\\t\\t\\t}\\n\\t\\t\\tif (t < 1) {\\n\\t\\t\\t\\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\\n\\t\\t\\t}\\n\\t\\t\\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\\n\\t\\t},\\n\\t\\teaseInBack: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\treturn 1 * (t /= 1) * t * ((s + 1) * t - s);\\n\\t\\t},\\n\\t\\teaseOutBack: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\treturn 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);\\n\\t\\t},\\n\\t\\teaseInOutBack: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\\n\\t\\t},\\n\\t\\teaseInBounce: function(t) {\\n\\t\\t\\treturn 1 - easingEffects.easeOutBounce(1 - t);\\n\\t\\t},\\n\\t\\teaseOutBounce: function(t) {\\n\\t\\t\\tif ((t /= 1) < (1 / 2.75)) {\\n\\t\\t\\t\\treturn 1 * (7.5625 * t * t);\\n\\t\\t\\t} else if (t < (2 / 2.75)) {\\n\\t\\t\\t\\treturn 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);\\n\\t\\t\\t} else if (t < (2.5 / 2.75)) {\\n\\t\\t\\t\\treturn 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\teaseInOutBounce: function(t) {\\n\\t\\t\\tif (t < 1 / 2) {\\n\\t\\t\\t\\treturn easingEffects.easeInBounce(t * 2) * 0.5;\\n\\t\\t\\t}\\n\\t\\t\\treturn easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;\\n\\t\\t}\\n\\t};\\n\\t//Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\\n\\thelpers.requestAnimFrame = (function() {\\n\\t\\treturn window.requestAnimationFrame ||\\n\\t\\t\\twindow.webkitRequestAnimationFrame ||\\n\\t\\t\\twindow.mozRequestAnimationFrame ||\\n\\t\\t\\twindow.oRequestAnimationFrame ||\\n\\t\\t\\twindow.msRequestAnimationFrame ||\\n\\t\\t\\tfunction(callback) {\\n\\t\\t\\t\\treturn window.setTimeout(callback, 1000 / 60);\\n\\t\\t\\t};\\n\\t})();\\n\\thelpers.cancelAnimFrame = (function() {\\n\\t\\treturn window.cancelAnimationFrame ||\\n\\t\\t\\twindow.webkitCancelAnimationFrame ||\\n\\t\\t\\twindow.mozCancelAnimationFrame ||\\n\\t\\t\\twindow.oCancelAnimationFrame ||\\n\\t\\t\\twindow.msCancelAnimationFrame ||\\n\\t\\t\\tfunction(callback) {\\n\\t\\t\\t\\treturn window.clearTimeout(callback, 1000 / 60);\\n\\t\\t\\t};\\n\\t})();\\n\\t//-- DOM methods\\n\\thelpers.getRelativePosition = function(evt, chart) {\\n\\t\\tvar mouseX, mouseY;\\n\\t\\tvar e = evt.originalEvent || evt,\\n\\t\\t\\tcanvas = evt.currentTarget || evt.srcElement,\\n\\t\\t\\tboundingRect = canvas.getBoundingClientRect();\\n\\n\\t\\tif (e.touches && e.touches.length > 0) {\\n\\t\\t\\tmouseX = e.touches[0].clientX;\\n\\t\\t\\tmouseY = e.touches[0].clientY;\\n\\n\\t\\t} else {\\n\\t\\t\\tmouseX = e.clientX;\\n\\t\\t\\tmouseY = e.clientY;\\n\\t\\t}\\n\\n\\t\\t// Scale mouse coordinates into canvas coordinates\\n\\t\\t// by following the pattern laid out by 'jerryj' in the comments of\\n\\t\\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\\n\\t\\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\\n\\t\\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\\n\\t\\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\\n\\t\\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\\n\\t\\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\\n\\t\\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\\n\\n\\t\\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\\n\\t\\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\\n\\t\\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\\n\\t\\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\\n\\n\\t\\treturn {\\n\\t\\t\\tx: mouseX,\\n\\t\\t\\ty: mouseY\\n\\t\\t};\\n\\n\\t};\\n\\thelpers.addEvent = function(node, eventType, method) {\\n\\t\\tif (node.addEventListener) {\\n\\t\\t\\tnode.addEventListener(eventType, method);\\n\\t\\t} else if (node.attachEvent) {\\n\\t\\t\\tnode.attachEvent(\\\"on\\\" + eventType, method);\\n\\t\\t} else {\\n\\t\\t\\tnode[\\\"on\\\" + eventType] = method;\\n\\t\\t}\\n\\t};\\n\\thelpers.removeEvent = function(node, eventType, handler) {\\n\\t\\tif (node.removeEventListener) {\\n\\t\\t\\tnode.removeEventListener(eventType, handler, false);\\n\\t\\t} else if (node.detachEvent) {\\n\\t\\t\\tnode.detachEvent(\\\"on\\\" + eventType, handler);\\n\\t\\t} else {\\n\\t\\t\\tnode[\\\"on\\\" + eventType] = helpers.noop;\\n\\t\\t}\\n\\t};\\n\\thelpers.bindEvents = function(chartInstance, arrayOfEvents, handler) {\\n\\t\\t// Create the events object if it's not already present\\n\\t\\tif (!chartInstance.events)\\n\\t\\t\\tchartInstance.events = {};\\n\\n\\t\\thelpers.each(arrayOfEvents, function(eventName) {\\n\\t\\t\\tchartInstance.events[eventName] = function() {\\n\\t\\t\\t\\thandler.apply(chartInstance, arguments);\\n\\t\\t\\t};\\n\\t\\t\\thelpers.addEvent(chartInstance.chart.canvas, eventName, chartInstance.events[eventName]);\\n\\t\\t});\\n\\t};\\n\\thelpers.unbindEvents = function(chartInstance, arrayOfEvents) {\\n\\t\\thelpers.each(arrayOfEvents, function(handler, eventName) {\\n\\t\\t\\thelpers.removeEvent(chartInstance.chart.canvas, eventName, handler);\\n\\t\\t});\\n\\t};\\n\\n\\t// Private helper function to convert max-width/max-height values that may be percentages into a number\\n\\tfunction parseMaxStyle(styleValue, node, parentProperty) {\\n\\t\\tvar valueInPixels;\\n\\t\\tif (typeof(styleValue) === 'string') {\\n\\t\\t\\tvalueInPixels = parseInt(styleValue, 10);\\n\\n\\t\\t\\tif (styleValue.indexOf('%') != -1) {\\n\\t\\t\\t\\t// percentage * size in dimension\\n\\t\\t\\t\\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tvalueInPixels = styleValue;\\n\\t\\t}\\n\\n\\t\\treturn valueInPixels;\\n\\t}\\n\\n\\t// Private helper to get a constraint dimension\\n\\t// @param domNode : the node to check the constraint on\\n\\t// @param maxStyle : the style that defines the maximum for the direction we are using (max-width / max-height)\\n\\t// @param percentageProperty : property of parent to use when calculating width as a percentage\\n\\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\\n\\t\\tvar constrainedDimension;\\n\\t\\tvar constrainedNode = document.defaultView.getComputedStyle(domNode)[maxStyle];\\n\\t\\tvar constrainedContainer = document.defaultView.getComputedStyle(domNode.parentNode)[maxStyle];\\n\\t\\tvar hasCNode = constrainedNode !== null && constrainedNode !== \\\"none\\\";\\n\\t\\tvar hasCContainer = constrainedContainer !== null && constrainedContainer !== \\\"none\\\";\\n\\n\\t\\tif (hasCNode || hasCContainer) {\\n\\t\\t\\tconstrainedDimension = Math.min((hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : Number.POSITIVE_INFINITY), (hasCContainer ? parseMaxStyle(constrainedContainer, domNode.parentNode, percentageProperty) : Number.POSITIVE_INFINITY));\\n\\t\\t}\\n\\t\\treturn constrainedDimension;\\n\\t}\\n\\t// returns Number or undefined if no constraint\\n\\thelpers.getConstraintWidth = function(domNode) {\\n\\t\\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\\n\\t};\\n\\t// returns Number or undefined if no constraint\\n\\thelpers.getConstraintHeight = function(domNode) {\\n\\t\\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\\n\\t};\\n\\thelpers.getMaximumWidth = function(domNode) {\\n\\t\\tvar container = domNode.parentNode;\\n\\t\\tvar padding = parseInt(helpers.getStyle(container, 'padding-left')) + parseInt(helpers.getStyle(container, 'padding-right'));\\n\\n\\t\\tvar w = container.clientWidth - padding;\\n\\t\\tvar cw = helpers.getConstraintWidth(domNode);\\n\\t\\tif (cw !== undefined) {\\n\\t\\t\\tw = Math.min(w, cw);\\n\\t\\t}\\n\\n\\t\\treturn w;\\n\\t};\\n\\thelpers.getMaximumHeight = function(domNode) {\\n\\t\\tvar container = domNode.parentNode;\\n\\t\\tvar padding = parseInt(helpers.getStyle(container, 'padding-top')) + parseInt(helpers.getStyle(container, 'padding-bottom'));\\n\\n\\t\\tvar h = container.clientHeight - padding;\\n\\t\\tvar ch = helpers.getConstraintHeight(domNode);\\n\\t\\tif (ch !== undefined) {\\n\\t\\t\\th = Math.min(h, ch);\\n\\t\\t}\\n\\n\\t\\treturn h;\\n\\t};\\n\\thelpers.getStyle = function(el, property) {\\n\\t\\treturn el.currentStyle ?\\n\\t\\t\\tel.currentStyle[property] :\\n\\t\\t\\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\\n\\t};\\n\\thelpers.retinaScale = function(chart) {\\n\\t\\tvar ctx = chart.ctx;\\n\\t\\tvar width = chart.canvas.width;\\n\\t\\tvar height = chart.canvas.height;\\n\\t\\tvar pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;\\n\\n\\t\\tif (pixelRatio !== 1) {\\n\\t\\t\\tctx.canvas.height = height * pixelRatio;\\n\\t\\t\\tctx.canvas.width = width * pixelRatio;\\n\\t\\t\\tctx.scale(pixelRatio, pixelRatio);\\n\\n\\t\\t\\t// Store the device pixel ratio so that we can go backwards in `destroy`.\\n\\t\\t\\t// The devicePixelRatio changes with zoom, so there are no guarantees that it is the same\\n\\t\\t\\t// when destroy is called\\n\\t\\t\\tchart.originalDevicePixelRatio = chart.originalDevicePixelRatio || pixelRatio;\\n\\t\\t}\\n\\n\\t\\tctx.canvas.style.width = width + 'px';\\n\\t\\tctx.canvas.style.height = height + 'px';\\n\\t};\\n\\t//-- Canvas methods\\n\\thelpers.clear = function(chart) {\\n\\t\\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\\n\\t};\\n\\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\\n\\t\\treturn fontStyle + \\\" \\\" + pixelSize + \\\"px \\\" + fontFamily;\\n\\t};\\n\\thelpers.longestText = function(ctx, font, arrayOfStrings, cache) {\\n\\t\\tcache = cache || {};\\n\\t\\tcache.data = cache.data || {};\\n\\t\\tcache.garbageCollect = cache.garbageCollect || [];\\n\\n\\t\\tif (cache.font !== font) {\\n\\t\\t\\tcache.data = {};\\n\\t\\t\\tcache.garbageCollect = [];\\n\\t\\t\\tcache.font = font;\\n\\t\\t}\\n\\n\\t\\tctx.font = font;\\n\\t\\tvar longest = 0;\\n\\t\\thelpers.each(arrayOfStrings, function(string) {\\n\\t\\t\\tvar textWidth = cache.data[string];\\n\\t\\t\\tif (!textWidth) {\\n\\t\\t\\t\\ttextWidth = cache.data[string] = ctx.measureText(string).width;\\n\\t\\t\\t\\tcache.garbageCollect.push(string);\\n\\t\\t\\t}\\n\\t\\t\\tif (textWidth > longest)\\n\\t\\t\\t\\tlongest = textWidth;\\n\\t\\t});\\n\\n\\t\\tvar gcLen = cache.garbageCollect.length / 2;\\n\\t\\tif (gcLen > arrayOfStrings.length) {\\n\\t\\t\\tfor (var i = 0; i < gcLen; i++) {\\n\\t\\t\\t\\tdelete cache.data[cache.garbageCollect[i]];\\n\\t\\t\\t}\\n\\t\\t\\tcache.garbageCollect.splice(0, gcLen);\\n\\t\\t}\\n\\n\\t\\treturn longest;\\n\\t};\\n\\thelpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {\\n\\t\\tctx.beginPath();\\n\\t\\tctx.moveTo(x + radius, y);\\n\\t\\tctx.lineTo(x + width - radius, y);\\n\\t\\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\\n\\t\\tctx.lineTo(x + width, y + height - radius);\\n\\t\\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\\n\\t\\tctx.lineTo(x + radius, y + height);\\n\\t\\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\\n\\t\\tctx.lineTo(x, y + radius);\\n\\t\\tctx.quadraticCurveTo(x, y, x + radius, y);\\n\\t\\tctx.closePath();\\n\\t};\\n\\thelpers.color = function(c) {\\n\\t\\tif (!color) {\\n\\t\\t\\t"]}